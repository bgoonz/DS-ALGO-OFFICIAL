<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>README</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="z-algorithm">Z Algorithm</h1>
    <p>
      The Z-algorithm finds occurrences of a “word” <code>W</code> within a main
      “text string” <code>T</code> in linear time <code>O(|W| + |T|)</code>.
    </p>
    <p>
      Given a string <code>S</code> of length <code>n</code>, the algorithm
      produces an array, <code>Z</code> where <code>Z[i]</code> represents the
      longest substring starting from <code>S[i]</code> which is also a prefix
      of <code>S</code>. Finding <code>Z</code> for the string obtained by
      concatenating the word, <code>W</code> with a nonce character, say
      <code>$</code> followed by the text, <code>T</code>, helps with pattern
      matching, for if there is some index <code>i</code> such that
      <code>Z[i]</code> equals the pattern length, then the pattern must be
      present at that point.
    </p>
    <p>
      While the <code>Z</code> array can be computed with two nested loops in
      <code>O(|W| * |T|)</code> time, the following strategy shows how to obtain
      it in linear time, based on the idea that as we iterate over the letters
      in the string (index <code>i</code> from <code>1</code> to
      <code>n - 1</code>), we maintain an interval <code>[L, R]</code> which is
      the interval with maximum <code>R</code> such that
      <code>1 ≤ L ≤ i ≤ R</code> and <code>S[L...R]</code> is a prefix that is
      also a substring (if no such interval exists, just let
      <code>L = R =  - 1</code>). For <code>i = 1</code>, we can simply compute
      <code>L</code> and <code>R</code> by comparing <code>S[0...]</code> to
      <code>S[1...]</code>.
    </p>
    <p><strong>Example of Z array</strong></p>
    <pre><code>Index            0   1   2   3   4   5   6   7   8   9  10  11 
Text             a   a   b   c   a   a   b   x   a   a   a   z
Z values         X   1   0   0   3   1   0   0   2   2   1   0 </code></pre>
    <p>Other examples</p>
    <pre><code>str =  a a a a a a
Z[] =  x 5 4 3 2 1</code></pre>
    <pre><code>str =  a a b a a c d
Z[] =  x 1 0 2 1 0 0</code></pre>
    <pre><code>str =  a b a b a b a b
Z[] =  x 0 6 0 4 0 2 0</code></pre>
    <p><strong>Example of Z box</strong></p>
    <figure>
      <img
        src="https://ivanyu.me/wp-content/uploads/2014/09/zalg1.png"
        alt="z-box"
      />
      <figcaption>z-box</figcaption>
    </figure>
    <h2 id="complexity">Complexity</h2>
    <ul>
      <li><strong>Time:</strong> <code>O(|W| + |T|)</code></li>
      <li><strong>Space:</strong> <code>O(|W|)</code></li>
    </ul>
    <h2 id="references">References</h2>
    <ul>
      <li>
        <a
          href="https://www.geeksforgeeks.org/z-algorithm-linear-time-pattern-searching-algorithm/"
          >GeeksForGeeks</a
        >
      </li>
      <li>
        <a
          href="https://www.youtube.com/watch?v=CpZh4eF8QBw&amp;t=0s&amp;list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8&amp;index=70"
          >YouTube</a
        >
      </li>
      <li>
        <a href="https://ivanyu.me/blog/2013/10/15/z-algorithm/"
          >Z Algorithm by Ivan Yurchenko</a
        >
      </li>
    </ul>
  </body>
</html>
