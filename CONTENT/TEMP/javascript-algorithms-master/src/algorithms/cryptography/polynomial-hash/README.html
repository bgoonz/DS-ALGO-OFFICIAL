<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="polynomial-rolling-hash">Polynomial Rolling Hash</h1>
<h2 id="hash-function">Hash Function</h2>
<p><strong>Hash functions</strong> are used to map large data sets of elements of an arbitrary length (<em>the keys</em>) to smaller data sets of elements of a fixed length (<em>the fingerprints</em>).</p>
<p>The basic application of hashing is efficient testing of equality of keys by comparing their fingerprints.</p>
<p>A <em>collision</em> happens when two different keys have the same fingerprint. The way in which collisions are handled is crucial in most applications of hashing. Hashing is particularly useful in construction of efficient practical algorithms.</p>
<h2 id="rolling-hash">Rolling Hash</h2>
<p>A <strong>rolling hash</strong> (also known as recursive hashing or rolling checksum) is a hash function where the input is hashed in a window that moves through the input.</p>
<p>A few hash functions allow a rolling hash to be computed very quickly — the new hash value is rapidly calculated given only the following data:</p>
<ul>
<li>old hash value,</li>
<li>the old value removed from the window,</li>
<li>and the new value added to the window.</li>
</ul>
<h2 id="polynomial-string-hashing">Polynomial String Hashing</h2>
<p>An ideal hash function for strings should obviously depend both on the <em>multiset</em> of the symbols present in the key and on the <em>order</em> of the symbols. The most common family of such hash functions treats the symbols of a string as coefficients of a <em>polynomial</em> with an integer variable <code>p</code> and computes its value modulo an integer constant <code>M</code>:</p>
<p>The <em>Rabin–Karp string search algorithm</em> is often explained using a very simple rolling hash function that only uses multiplications and additions - <strong>polynomial rolling hash</strong>:</p>
<blockquote>
<p>H(s<sub>0</sub>, s<sub>1</sub>, …, s<sub>k</sub>) = s<sub>0</sub> * p<sup>k-1</sup> + s<sub>1</sub> * p<sup>k-2</sup> + … + s<sub>k</sub> * p<sup>0</sup></p>
</blockquote>
<p>where <code>p</code> is a constant, and <em>(s<sub>1</sub>, … , s<sub>k</sub>)</em> are the input characters.</p>
<p>For example we can convert short strings to key numbers by multiplying digit codes by powers of a constant. The three letter word <code>ace</code> could turn into a number by calculating:</p>
<blockquote>
<p>key = 1 * 26<sup>2</sup> + 3 * 26<sup>1</sup> + 5 * 26<sup>0</sup></p>
</blockquote>
<p>In order to avoid manipulating huge <code>H</code> values, all math is done modulo <code>M</code>.</p>
<blockquote>
<p>H(s<sub>0</sub>, s<sub>1</sub>, …, s<sub>k</sub>) = (s<sub>0</sub> * p<sup>k-1</sup> + s<sub>1</sub> * p<sup>k-2</sup> + … + s<sub>k</sub> * p<sup>0</sup>) mod M</p>
</blockquote>
<p>A careful choice of the parameters <code>M</code>, <code>p</code> is important to obtain “good” properties of the hash function, i.e., low collision rate.</p>
<p>This approach has the desirable attribute of involving all the characters in the input string. The calculated key value can then be hashed into an array index in the usual way:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">function</span> <span class="at">hash</span>(key<span class="op">,</span> arraySize) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">const</span> base <span class="op">=</span> <span class="dv">13</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">let</span> hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="cf">for</span> (<span class="kw">let</span> charIndex <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> charIndex <span class="op">&lt;</span> <span class="va">key</span>.<span class="at">length</span><span class="op">;</span> charIndex <span class="op">+=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="kw">const</span> charCode <span class="op">=</span> <span class="va">key</span>.<span class="at">charCodeAt</span>(charIndex)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-7" title="7">    hash <span class="op">+=</span> charCode <span class="op">*</span> (base <span class="op">**</span> (<span class="va">key</span>.<span class="at">length</span> <span class="op">-</span> charIndex <span class="op">-</span> <span class="dv">1</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb1-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10">  <span class="cf">return</span> hash <span class="op">%</span> arraySize<span class="op">;</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="op">}</span></a></code></pre></div>
<p>The <code>hash()</code> method is not as efficient as it might be. Other than the character conversion, there are two multiplications and an addition inside the loop. We can eliminate one multiplication by using **Horner’s method*:</p>
<blockquote>
<p>a<sub>4</sub> * x<sup>4</sup> + a<sub>3</sub> * x<sup>3</sup> + a<sub>2</sub> * x<sup>2</sup> + a<sub>1</sub> * x<sup>1</sup> + a<sub>0</sub> = (((a<sub>4</sub> * x + a<sub>3</sub>) * x + a<sub>2</sub>) * x + a<sub>1</sub>) * x + a<sub>0</sub></p>
</blockquote>
<p>In other words:</p>
<blockquote>
<p>H<sub>i</sub> = (P * H<sub>i-1</sub> + S<sub>i</sub>) mod M</p>
</blockquote>
<p>The <code>hash()</code> cannot handle long strings because the hashVal exceeds the size of int. Notice that the key always ends up being less than the array size. In Horner’s method we can apply the modulo (%) operator at each step in the calculation. This gives the same result as applying the modulo operator once at the end, but avoids the overflow.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="at">hash</span>(key<span class="op">,</span> arraySize) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">const</span> base <span class="op">=</span> <span class="dv">13</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="kw">let</span> hash <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="cf">for</span> (<span class="kw">let</span> charIndex <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> charIndex <span class="op">&lt;</span> <span class="va">key</span>.<span class="at">length</span><span class="op">;</span> charIndex <span class="op">+=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="kw">const</span> charCode <span class="op">=</span> <span class="va">key</span>.<span class="at">charCodeAt</span>(charIndex)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7">    hash <span class="op">=</span> (hash <span class="op">*</span> base <span class="op">+</span> charCode) <span class="op">%</span> arraySize<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-9" title="9"></a>
<a class="sourceLine" id="cb2-10" title="10">  <span class="cf">return</span> hash<span class="op">;</span></a>
<a class="sourceLine" id="cb2-11" title="11"><span class="op">}</span></a></code></pre></div>
<p>Polynomial hashing has a rolling property: the fingerprints can be updated efficiently when symbols are added or removed at the ends of the string (provided that an array of powers of p modulo M of sufficient length is stored). The popular Rabin–Karp pattern matching algorithm is based on this property</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.mii.lt/olympiads_in_informatics/pdf/INFOL119.pdf">Where to Use Polynomial String Hashing</a></li>
<li><a href="https://www.cs.utexas.edu/~mitra/csSpring2017/cs313/lectures/hash.html">Hashing on uTexas</a></li>
<li><a href="https://en.wikipedia.org/wiki/Hash_function">Hash Function on Wikipedia</a></li>
<li><a href="https://en.wikipedia.org/wiki/Rolling_hash">Rolling Hash on Wikipedia</a></li>
</ul>
</body>
</html>
