<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.pt-BR</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="estrutura-de-dados-e-algoritmos-em-javascript">Estrutura de Dados e Algoritmos em JavaScript</h1>
<p><a href="https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg" alt="CI" /></a> <a href="https://codecov.io/gh/trekhleb/javascript-algorithms"><img src="https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg" alt="codecov" /></a></p>
<p>Este repositório contém exemplos baseados em JavaScript de muitos algoritmos e estruturas de dados populares.</p>
<p>Cada algoritmo e estrutura de dado possui seu próprio README com explicações relacionadas e links para leitura adicional (incluindo vídeos para YouTube)</p>
<p><em>Leia isto em outros idiomas:</em> <a href="https://github.com/trekhleb/javascript-algorithms/"><em>English</em></a> <a href="README.zh-CN.md"><em>简体中文</em></a>, <a href="README.zh-TW.md"><em>繁體中文</em></a>, <a href="README.ko-KR.md"><em>한국어</em></a>, <a href="README.ja-JP.md"><em>日本語</em></a>, <a href="README.pl-PL.md"><em>Polski</em></a>, <a href="README.fr-FR.md"><em>Français</em></a>, <a href="README.es-ES.md"><em>Español</em></a>, <a href="README.ru-RU.md"><em>Русский</em></a>, <a href="README.tr-TR.md"><em>Türk</em></a>, <a href="README.it-IT.md"><em>Italiana</em></a>, <a href="README.id-ID.md"><em>Bahasa Indonesia</em></a>, <a href="README.uk-UA.md"><em>Українська</em></a>, <a href="README.ar-AR.md"><em>Arabic</em></a>, <a href="README.de-DE.md"><em>Deutsch</em></a></p>
<h2 id="estrutura-de-dados">Estrutura de Dados</h2>
<p>Uma estrutura de dados é uma maneira particular de organizar e armazenar dados em um computador para que ele possa ser acessado e modificado de forma eficiente. Mais precisamente, uma estrutura de dados é uma coleção de dados valores, as relações entre eles e as funções ou operações que podem ser aplicadas a os dados.</p>
<p><code>B</code> - Iniciante, <code>A</code> - Avançado</p>
<ul>
<li><code>B</code> <a href="src/data-structures/linked-list/README.pt-BR.md">Lista Encadeada (Linked List)</a></li>
<li><code>B</code> <a href="src/data-structures/doubly-linked-list/README.pt-BR.md">Lista Duplamente Ligada (Doubly Linked List)</a></li>
<li><code>B</code> <a href="src/data-structures/queue/README.pt-BR.md">Fila (Queue)</a></li>
<li><code>B</code> <a href="src/data-structures/stack/README.pt-BR.md">Pilha (Stack)</a></li>
<li><code>B</code> <a href="src/data-structures/hash-table/README.pt-BR.md">Tabela de Hash (Hash Table)</a></li>
<li><code>B</code> <a href="src/data-structures/heap/README.pt-BR.md">Heap</a></li>
<li><code>B</code> <a href="src/data-structures/priority-queue/README.pt-BR.md">Fila de Prioridade (Priority Queue)</a></li>
<li><code>A</code> <a href="src/data-structures/trie/README.pt-BR.md">Árvore de prefixos (Trie)</a></li>
<li><code>A</code> <a href="src/data-structures/tree/README.pt-BR.md">Árvore (Tree)</a>
<ul>
<li><code>A</code> <a href="src/data-structures/tree/binary-search-tree/README.pt-BR.md">Árvore de Pesquisa Binária (Binary Search Tree)</a></li>
<li><code>A</code> <a href="src/data-structures/tree/avl-tree/README.pt-BR.md">Árvore AVL (AVL Tree)</a></li>
<li><code>A</code> <a href="src/data-structures/tree/red-black-tree/README.pt-BR.md">Árvore Vermelha-Preta (Red-Black Tree)</a></li>
<li><code>A</code> <a href="src/data-structures/tree/segment-tree/README.pt-BR.md">Árvore de Segmento (Segment Tree)</a> - com exemplos de consultas min / max / sum range</li>
<li><code>A</code> <a href="src/data-structures/tree/fenwick-tree/README.pt-BR.md">Árvore Fenwick (Fenwick Tree)</a> (Árvore indexada binária)</li>
</ul></li>
<li><code>A</code> <a href="src/data-structures/graph/README.pt-BR.md">Grafo (Graph)</a> (ambos dirigidos e não direcionados)</li>
<li><code>A</code> <a href="src/data-structures/disjoint-set/README.pt-BR.md">Conjunto Disjuntor (Disjoint Set)</a></li>
<li><code>A</code> <a href="src/data-structures/bloom-filter/README.pt-BR.md">Filtro Bloom (Bloom Filter)</a></li>
</ul>
<h2 id="algoritmos">Algoritmos</h2>
<p>Um algoritmo é uma especificação inequívoca de como resolver uma classe de problemas. Isto é um conjunto de regras que define precisamente uma sequência de operações.</p>
<p><code>B</code> - Iniciante, <code>A</code> - Avançado</p>
<h3 id="algoritmos-por-tópico">Algoritmos por Tópico</h3>
<ul>
<li><strong>Matemática</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/math/bits">Manipulação Bit</a> - set/get/update/clear bits, multiplicação / divisão por dois, tornar negativo etc.</li>
<li><code>B</code> <a href="src/algorithms/math/factorial">Fatorial</a></li>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Número de Fibonacci</a></li>
<li><code>B</code> <a href="src/algorithms/math/primality-test">Teste de Primalidade</a> (método de divisão experimental)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Algoritmo Euclidiano</a> - calcular o maior divisor comum (GCD)</li>
<li><code>B</code> <a href="src/algorithms/math/least-common-multiple">Mínimo múltiplo comum</a> (LCM)</li>
<li><code>B</code> <a href="src/algorithms/math/sieve-of-eratosthenes">Peneira de Eratóstenes</a> - encontrar todos os números primos até um determinado limite</li>
<li><code>B</code> <a href="src/algorithms/math/is-power-of-two">Potência de dois</a> - verifique se o número é a potência de dois (algoritmos ingênuos e bit a bit)</li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Triângulo de Pascal</a></li>
<li><code>B</code> <a href="src/algorithms/math/complex-number">Número complexo</a> - números complexos e operações básicas com eles</li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Partição inteira</a></li>
<li><code>A</code> <a href="src/algorithms/math/liu-hui">Algoritmo Liu Hui π</a> - cálculos aproximados de π baseados em N-gons</li>
</ul></li>
<li><strong>Conjuntos</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sets/cartesian-product">Produto cartesiano</a> - produto de vários conjuntos</li>
<li><code>B</code> <a href="src/algorithms/sets/fisher-yates">Permutações de Fisher–Yates</a> - permutação aleatória de uma sequência finita</li>
<li><code>A</code> <a href="src/algorithms/sets/power-set">Potência e Conjunto</a> - todos os subconjuntos de um conjunto</li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutações</a> (com e sem repetições)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Combinações</a> (com e sem repetições)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Mais longa subsequência comum</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Maior subsequência crescente</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Supersequência Comum mais curta</a> (SCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Problema da mochila</a> - “0/1” e “Não consolidado”</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Máximo Subarray</a> - “Força bruta” e " Programação Dinâmica" versões (Kadane’s)</li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Soma de Combinação</a> - encontre todas as combinações que formam uma soma específica</li>
</ul></li>
<li><strong>Cadeia de Caracteres</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/string/hamming-distance">Hamming Distance</a> - número de posições em que os símbolos são diferentes</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Levenshtein Distance</a> - distância mínima de edição entre duas sequências</li>
<li><code>A</code> <a href="src/algorithms/string/knuth-morris-pratt">Knuth–Morris–Pratt Algorithm</a> (Algoritmo KMP) - pesquisa de substring (correspondência de padrão)</li>
<li><code>A</code> <a href="src/algorithms/string/z-algorithm">Z Algorithm</a> - pesquisa de substring (correspondência de padrão)</li>
<li><code>A</code> <a href="src/algorithms/string/rabin-karp">Rabin Karp Algorithm</a> - pesquisa de substring</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Longest Common Substring</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Regular Expression Matching</a></li>
</ul></li>
<li><strong>Buscas</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Linear Search</a></li>
<li><code>B</code> <a href="src/algorithms/search/jump-search">Jump Search</a> (ou Bloquear pesquisa) - pesquisar na matriz ordenada</li>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Binary Search</a> - pesquisar na matriz ordenada</li>
<li><code>B</code> <a href="src/algorithms/search/interpolation-search">Interpolation Search</a> - pesquisar em matriz classificada uniformemente distribuída</li>
</ul></li>
<li><strong>Classificação</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sorting/bubble-sort">Bubble Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/selection-sort">Selection Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/insertion-sort">Insertion Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/heap-sort">Heap Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Merge Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Quicksort</a> - implementações local e não local</li>
<li><code>B</code> <a href="src/algorithms/sorting/shell-sort">Shellsort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/counting-sort">Counting Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/radix-sort">Radix Sort</a></li>
</ul></li>
<li><strong>Arvóres</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Depth-First Search</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/tree/breadth-first-search">Breadth-First Search</a> (BFS)</li>
</ul></li>
<li><strong>Grafos</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Depth-First Search</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/breadth-first-search">Breadth-First Search</a> (BFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/kruskal">Kruskal’s Algorithm</a> - encontrando Árvore Mínima de Abrangência (MST) para grafo não direcionado ponderado</li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Dijkstra Algorithm</a> - encontrar caminhos mais curtos para todos os vértices do grafo a partir de um único vértice</li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Bellman-Ford Algorithm</a> - encontrar caminhos mais curtos para todos os vértices do grafo a partir de um único vértice</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Floyd-Warshall Algorithm</a> - encontrar caminhos mais curtos entre todos os pares de vértices</li>
<li><code>A</code> <a href="src/algorithms/graph/detect-cycle">Detect Cycle</a> - para gráficos direcionados e não direcionados (versões baseadas em DFS e Conjunto Disjuntivo)</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Prim’s Algorithm</a> - encontrando Árvore Mínima de Abrangência (MST) para grafo não direcionado ponderado</li>
<li><code>A</code> <a href="src/algorithms/graph/topological-sorting">Topological Sorting</a> - Métodos DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/articulation-points">Articulation Points</a> -O algoritmo de Tarjan (baseado em DFS)</li>
<li><code>A</code> <a href="src/algorithms/graph/bridges">Bridges</a> - Algoritmo baseado em DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/eulerian-path">Eulerian Path and Eulerian Circuit</a> - Algoritmo de Fleury - Visite todas as bordas exatamente uma vez</li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Hamiltonian Cycle</a> - Visite todas as bordas exatamente uma vez</li>
<li><code>A</code> <a href="src/algorithms/graph/strongly-connected-components">Strongly Connected Components</a> - Algoritmo de Kosaraju’s</li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Travelling Salesman Problem</a> - rota mais curta possível que visita cada cidade e retorna à cidade de origem</li>
</ul></li>
<li><strong>criptografia</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/cryptography/polynomial-hash">Polynomial Hash</a> - função de hash de rolagem baseada em polinômio</li>
</ul></li>
<li><strong>Sem categoria</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Tower of Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/square-matrix-rotation">Square Matrix Rotation</a> - algoritmo no local</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a> - backtracking, programação dinâmica (top-down + bottom-up) e exemplos gananciosos</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unique Paths</a> - backtracking, programação dinâmica e exemplos baseados no triângulo de Pascal</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Rain Terraces</a> - trapping problema da água da chuva (programação dinâmica e versões de força bruta)</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">N-Queens Problem</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Knight’s Tour</a></li>
</ul></li>
</ul>
<h3 id="algoritmos-por-paradigma">Algoritmos por Paradigma</h3>
<p>Um paradigma algorítmico é um método ou abordagem genérica subjacente ao design de uma classe de algoritmos. É uma abstração maior do que a noção de um algoritmo, assim como algoritmo é uma abstração maior que um programa de computador.</p>
<ul>
<li><strong>Força bruta</strong> - look at all the possibilities and selects the best solution
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Linear Search</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Rain Terraces</a> - trapping problema da água da chuva</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximum Subarray</a></li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Travelling Salesman Problem</a> - rota mais curta possível que visita cada cidade e retorna à cidade de origem</li>
</ul></li>
<li><strong>Greedy</strong> - choose the best option at the current time, without any consideration for the future
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Unbound Knapsack Problem</a></li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Dijkstra Algorithm</a> - finding shortest path to all graph vertices</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Prim’s Algorithm</a> - encontrando Árvore Mínima de Abrangência (MST) para grafo não direcionado ponderado</li>
<li><code>A</code> <a href="src/algorithms/graph/kruskal">Kruskal’s Algorithm</a> - encontrando Árvore Mínima de Abrangência (MST) para grafo não direcionado ponderado</li>
</ul></li>
<li><strong>Dividir p/ Conquistar</strong> - dividir o problema em partes menores e depois resolver essas partes
<ul>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Busca binária (Binary Search)</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Tower of Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Pascal’s Triangle</a></li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Euclidean Algorithm</a> - calculate the Greatest Common Divisor (GCD)</li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Merge Sort</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Quicksort</a></li>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Tree Depth-First Search</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Graph Depth-First Search</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutations</a> (com e sem repetições)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Combinations</a> (com e sem repetições)</li>
</ul></li>
<li><strong>Programação Dinâmica</strong> - criar uma solução usando sub-soluções encontradas anteriormente
<ul>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Fibonacci Number</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unique Paths</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/rain-terraces">Rain Terraces</a> - trapping problema da água da chuva</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Levenshtein Distance</a> - distância mínima de edição entre duas sequências</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Longest Common Subsequence</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Longest Common Substring</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Longest Increasing Subsequence</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Shortest Common Supersequence</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">0/1 Knapsack Problem</a></li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Integer Partition</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maximum Subarray</a></li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Bellman-Ford Algorithm</a> - encontrando o caminho mais curto para todos os vértices do gráfico</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Floyd-Warshall Algorithm</a> - encontrar caminhos mais curtos entre todos os pares de vértices</li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Regular Expression Matching</a></li>
</ul></li>
<li><strong>Backtracking</strong> - da mesma forma que a força bruta, tente gerar todas as soluções possíveis, mas cada vez que você gerar a próxima solução, você testará se satisfizer todas as condições, e só então continuar gerando soluções subseqüentes. Caso contrário, volte atrás e siga um caminho diferente para encontrar uma solução. Normalmente, a passagem DFS do espaço de estados está sendo usada.
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unique Paths</a></li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Hamiltonian Cycle</a> - Visite todos os vértices exatamente uma vez</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">N-Queens Problem</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Knight’s Tour</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Combination Sum</a> - encontre todas as combinações que formam uma soma específica</li>
</ul></li>
<li><strong>Branch &amp; Bound</strong> - lembre-se da solução de menor custo encontrada em cada etapa do retrocesso pesquisar e usar o custo da solução de menor custo encontrada até o limite inferior do custo de solução de menor custo para o problema, a fim de descartar soluções parciais com custos maiores que o solução de menor custo encontrada até o momento. Normalmente, a travessia BFS em combinação com a passagem DFS do espaço de estados árvore está sendo usada</li>
</ul>
<h2 id="como-usar-este-repositório">Como usar este repositório</h2>
<p><strong>Instalar todas as dependências</strong></p>
<pre><code>npm install</code></pre>
<p><strong>Executar o ESLint</strong></p>
<p>Você pode querer executá-lo para verificar a qualidade do código.</p>
<pre><code>npm run lint</code></pre>
<p><strong>Execute todos os testes</strong></p>
<pre><code>npm test</code></pre>
<p><strong>Executar testes por nome</strong></p>
<pre><code>npm test -- &#39;LinkedList&#39;</code></pre>
<p><strong>Parque infantil</strong></p>
<p>Você pode brincar com estruturas de dados e algoritmos em <code>./src/playground/playground.js</code> arquivar e escrever testes para isso em <code>./src/playground/__test__/playground.test.js</code>.</p>
<p>Em seguida, basta executar o seguinte comando para testar se o código do seu playground funciona conforme o esperado:</p>
<pre><code>npm test -- &#39;playground&#39;</code></pre>
<h2 id="informação-útil">Informação útil</h2>
<h3 id="referências">Referências</h3>
<p><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">▶ Estruturas de dados e algoritmos no YouTube</a></p>
<h3 id="notação-big-o">Notação Big O</h3>
<p>Ordem de crescimento dos algoritmos especificados em notação Big O.</p>
<figure>
<img src="./assets/big-o-graph.png" alt="Notação Big-O" /><figcaption>Notação Big-O</figcaption>
</figure>
<p>Fonte: <a href="http://bigocheatsheet.com/">Notação Big-O dicas</a>.</p>
<p>Abaixo está a lista de algumas das notações Big O mais usadas e suas comparações de desempenho em relação aos diferentes tamanhos dos dados de entrada.</p>
<table>
<colgroup>
<col style="width: 13%" />
<col style="width: 27%" />
<col style="width: 28%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Notação Big-O</th>
<th>Cálculos para 10 elementos</th>
<th>Cálculos para 100 elementos</th>
<th>Cálculos para 1000 elementos</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>O(1)</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>O(log N)</strong></td>
<td>3</td>
<td>6</td>
<td>9</td>
</tr>
<tr class="odd">
<td><strong>O(N)</strong></td>
<td>10</td>
<td>100</td>
<td>1000</td>
</tr>
<tr class="even">
<td><strong>O(N log N)</strong></td>
<td>30</td>
<td>600</td>
<td>9000</td>
</tr>
<tr class="odd">
<td><strong>O(N^2)</strong></td>
<td>100</td>
<td>10000</td>
<td>1000000</td>
</tr>
<tr class="even">
<td><strong>O(2^N)</strong></td>
<td>1024</td>
<td>1.26e+29</td>
<td>1.07e+301</td>
</tr>
<tr class="odd">
<td><strong>O(N!)</strong></td>
<td>3628800</td>
<td>9.3e+157</td>
<td>4.02e+2567</td>
</tr>
</tbody>
</table>
<h3 id="complexidade-de-operações-de-estrutura-de-dados">Complexidade de operações de estrutura de dados</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 33%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th>estrutura de dados</th>
<th style="text-align: center;">Acesso</th>
<th style="text-align: center;">Busca</th>
<th style="text-align: center;">Inserção</th>
<th style="text-align: center;">Eliminação</th>
<th style="text-align: left;">comentários</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Array</strong></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Stack</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Queue</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Linked List</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Hash Table</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: left;">Em caso de uma função hash perfeita, os custos seriam O (1)</td>
</tr>
<tr class="even">
<td><strong>Binary Search Tree</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: left;">No caso de custos de árvore equilibrados seria O (log (n))</td>
</tr>
<tr class="odd">
<td><strong>B-Tree</strong></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Red-Black Tree</strong></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>AVL Tree</strong></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Bloom Filter</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-</td>
<td style="text-align: left;">Falsos positivos são possíveis durante a pesquisa</td>
</tr>
</tbody>
</table>
<h3 id="array-sorting-algorithms-complexity">Array Sorting Algorithms Complexity</h3>
<table style="width:100%;">
<colgroup>
<col style="width: 20%" />
<col style="width: 14%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 8%" />
<col style="width: 8%" />
<col style="width: 8%" />
</colgroup>
<thead>
<tr class="header">
<th>Nome</th>
<th style="text-align: center;">Melhor</th>
<th style="text-align: center;">Média</th>
<th style="text-align: center;">Pior</th>
<th style="text-align: center;">Mémoria</th>
<th style="text-align: center;">Estável</th>
<th style="text-align: left;">comentários</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Bubble sort</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Sim</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Insertion sort</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Sim</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Selection sort</strong></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Não</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Heap sort</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Não</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Merge sort</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">Sim</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Quick sort</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">Não</td>
<td style="text-align: left;">O Quicksort geralmente é feito no local com o espaço de pilha O O(log(n)) stack space</td>
</tr>
<tr class="odd">
<td><strong>Shell sort</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">depende da sequência de lacunas</td>
<td style="text-align: center;">n (log(n))<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Não</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Counting sort</strong></td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">Sim</td>
<td style="text-align: left;">r - maior número na matriz</td>
</tr>
<tr class="odd">
<td><strong>Radix sort</strong></td>
<td style="text-align: center;">n * k</td>
<td style="text-align: center;">n * k</td>
<td style="text-align: center;">n * k</td>
<td style="text-align: center;">n + k</td>
<td style="text-align: center;">Sim</td>
<td style="text-align: left;">k - comprimento da chave mais longa</td>
</tr>
</tbody>
</table>
<blockquote>
<p>ℹ️ A few more <a href="https://trekhleb.dev/projects/">projects</a> and <a href="https://trekhleb.dev/blog/">articles</a> about JavaScript and algorithms on <a href="https://trekhleb.dev">trekhleb.dev</a></p>
</blockquote>
</body>
</html>
