<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.pl-PL</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h1 id="javascript-algorytmy-i-struktury-danych">JavaScript Algorytmy i Struktury Danych</h1>
<p><a href="https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster"><img src="https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg" alt="CI" /></a> <a href="https://codecov.io/gh/trekhleb/javascript-algorithms"><img src="https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg" alt="codecov" /></a></p>
<p>To repozytorium zawiera wiele przykładów JavaScript opartych na znanych algorytmach i strukturach danych.</p>
<p>Każdy algorytm i struktura danych zawiera osobny plik README wraz z powiązanymi wyjaśnieniami i odnośnikami do dalszego czytania (włącznie z tymi do YouTube videos).</p>
<p><em>Read this in other languages:</em> <a href="https://github.com/trekhleb/javascript-algorithms/"><em>English</em></a> <a href="README.zh-CN.md"><em>简体中文</em></a>, <a href="README.zh-TW.md"><em>繁體中文</em></a>, <a href="README.ko-KR.md"><em>한국어</em></a>, <a href="README.ja-JP.md"><em>日本語</em></a>, <a href="README.fr-FR.md"><em>Français</em></a>, <a href="README.es-ES.md"><em>Español</em></a>, <a href="README.pt-BR.md"><em>Português</em></a>, <a href="README.ru-RU.md"><em>Русский</em></a>, <a href="README.tr-TR.md"><em>Türk</em></a>, <a href="README.it-IT.md"><em>Italiana</em></a>, <a href="README.id-ID.md"><em>Bahasa Indonesia</em></a>, <a href="README.uk-UA.md"><em>Українська</em></a>, <a href="README.ar-AR.md"><em>Arabic</em></a>, <a href="README.de-DE.md"><em>Deutsch</em></a></p>
<h2 id="struktury-danych">Struktury Danych</h2>
<p>Struktura danych to sposób uporządkowania i przechowywania informacji w komputerze żeby mogłaby być sprawnie dostępna i efektywnie zmodyfikowana. Dokładniej, struktura danych jest zbiorem wartości danych, relacjami pomiędzy nimi, zadaniami lub działaniami, które mogą dotyczyć danych.</p>
<p><code>B</code> - Początkujący, <code>A</code> - Zaawansowany</p>
<ul>
<li><code>B</code> <a href="src/data-structures/linked-list">Lista</a></li>
<li><code>B</code> <a href="src/data-structures/doubly-linked-list">Lista Dwukierunkowa</a></li>
<li><code>B</code> <a href="src/data-structures/queue">Kolejka</a></li>
<li><code>B</code> <a href="src/data-structures/stack">Stos</a></li>
<li><code>B</code> <a href="src/data-structures/hash-table">Tabela Skrótu</a></li>
<li><code>B</code> <a href="src/data-structures/heap">Sterta</a></li>
<li><code>B</code> <a href="src/data-structures/priority-queue">Kolejka Priorytetowa</a></li>
<li><code>A</code> <a href="src/data-structures/trie">Trie</a></li>
<li><code>A</code> <a href="src/data-structures/tree">Drzewo</a>
<ul>
<li><code>A</code> <a href="src/data-structures/tree/binary-search-tree">Wyszukiwanie Binarne</a></li>
<li><code>A</code> <a href="src/data-structures/tree/avl-tree">AVL Drzewo</a></li>
<li><code>A</code> <a href="src/data-structures/tree/red-black-tree">Drzewa czerwono-czarne</a></li>
<li><code>A</code> <a href="src/data-structures/tree/segment-tree">Drzewo Segmentu</a> - z przykładami zapytań o min / max / sumie sum</li>
<li><code>A</code> <a href="src/data-structures/tree/fenwick-tree">Drzewo Fenwicka</a> (Drzewo Indeksowane Binarnie)</li>
</ul></li>
<li><code>A</code> <a href="src/data-structures/graph">Graf</a> (zarówno skierowane i nieukierunkowane)</li>
<li><code>A</code> <a href="src/data-structures/disjoint-set">Rozłączny Zestaw</a></li>
<li><code>A</code> <a href="src/data-structures/bloom-filter">Filtr Blooma</a></li>
</ul>
<h2 id="algorytmy">Algorytmy</h2>
<p>Algorytm jest to skończony ciąg jasno zdefiniowanych czynności, koniecznych do wykonania pewnego rodzaju zadań. Sposób postępowania prowadzący do rozwiązania problemu.</p>
<p><code>B</code> - Początkujący, <code>A</code> - Zaawansowany</p>
<h3 id="algorytmy-według-tematu">Algorytmy według tematu</h3>
<ul>
<li><strong>Matematyka</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/math/bits">Manipulacja Bitami</a> - ustaw / uzyskaj / aktualizuj / usuwaj bity, mnożenie / dzielenie przez dwa, tworzenie negatywów itp.</li>
<li><code>B</code> <a href="src/algorithms/math/factorial">Silna</a></li>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Ciąg Fibonacciego</a></li>
<li><code>B</code> <a href="src/algorithms/math/primality-test">Test Pierwszorzędności</a> (metoda podziału na próby)</li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Algorytm Euclideana</a> - obliczyć Największy Wspólny Dzielnik (GCD)</li>
<li><code>B</code> <a href="src/algorithms/math/least-common-multiple">Najmniejsza Wspólna Wielokrotność</a> (LCM)</li>
<li><code>B</code> <a href="src/algorithms/math/sieve-of-eratosthenes">Sito Eratosthenes-a</a> - znajdowanie wszystkich liczb pierwszych do określonego limitu</li>
<li><code>B</code> <a href="src/algorithms/math/is-power-of-two">Jest Potęgą Dwójki</a> - sprawdź, czy liczba jest potęgą dwóch (algorytmy naiwne i bitowe)</li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Trójkąt Pascala</a></li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Partycja Całkowita</a></li>
<li><code>A</code> <a href="src/algorithms/math/liu-hui">Algorytm Liu Huia</a> - przybliżone obliczenia na podstawie N-gonów</li>
</ul></li>
<li><strong>Zestawy</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sets/cartesian-product">Produkt Kartezyjny</a> - wynik wielu zestawów</li>
<li><code>B</code> <a href="src/algorithms/sets/fisher-yates">Przetasowanie Fisher Yates-a</a> - losowa permutacja kończącej się serii</li>
<li><code>A</code> <a href="src/algorithms/sets/power-set">Zestaw Zasilający</a> - podzbiór wszystkich serii</li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutacje</a> (z albo bez powtórzeń)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Kombinacje</a> (z albo bez powtórzeń)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Najdłuższa Wspólna Podsekwencja</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Najdłuższa Wzrostająca Podsekwencja</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Najkrótsza Wspólna Supersekwencja</a> (SCS)</li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Problem Knapsacka</a> - “0/1” i “Rozwiązany”</li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maksymalna Podtablica</a> - “Metoda Siłowa” i “Dynamiczne Programowanie” (Kadane-a) wersje</li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Suma Kombinacji</a> - znajdź wszystkie kombinacje, które tworzą określoną sumę</li>
</ul></li>
<li><strong>Łańcuchy</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/string/hamming-distance">Odległość Hamminga</a> - liczba pozycji, w których symbole są różne</li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Odległość Levenshteina</a> - minimalna odległość edycji między dwiema sekwencjami</li>
<li><code>A</code> <a href="src/algorithms/string/knuth-morris-pratt">Algorytm Knuth–Morris–Pratta</a> (Algorytm KMP) - dopasowywanie wzorców (dopasowywanie wzorców)</li>
<li><code>A</code> <a href="src/algorithms/string/z-algorithm">Algorytm Z</a> - szukanie podłańcucha(dopasowywanie wzorców)</li>
<li><code>A</code> <a href="src/algorithms/string/rabin-karp">Algorytm Rabin Karpa</a> - szukanie podłańcucha</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Najdłuższa Wspólna Podłańcucha</a></li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Dopasowanie Wyrażeń Regularnych</a></li>
</ul></li>
<li><strong>Szukanie</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Wyszukiwanie Liniowe</a></li>
<li><code>B</code> <a href="src/algorithms/search/jump-search">Jump Search</a> (lub Przeszukiwanie Bloku) - szukaj w posortowanej tablicy</li>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Wyszukiwanie Binarne</a> - szukaj w posortowanej tablicy</li>
<li><code>B</code> <a href="src/algorithms/search/interpolation-search">Wyszukiwanie Interpolacyjne</a> - szukaj w równomiernie rozłożonej, posortowanej tablicy</li>
</ul></li>
<li><strong>Sortowanie</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/sorting/bubble-sort">Sortowanie bąbelkowe</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/selection-sort">Sortowanie przez wymiane</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/insertion-sort">Sortowanie przez wstawianie</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/heap-sort">Sortowanie stogowe</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Sortowanie przez scalanie</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Sortowanie szybkie</a> - wdrożenia w miejscu i nie na miejscu</li>
<li><code>B</code> <a href="src/algorithms/sorting/shell-sort">Sortowanie Shella</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/counting-sort">Sortowanie przez zliczanie</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/radix-sort">Sortowanie pozycyjne</a></li>
</ul></li>
<li><strong>Drzewa</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Przeszukiwanie w głąb</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/tree/breadth-first-search">Przeszukiwanie wszerz</a> (BFS)</li>
</ul></li>
<li><strong>Grafy</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Przeszukiwanie w głąb</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/breadth-first-search">Przeszukiwanie wszerz</a> (BFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/kruskal">Algorytm Kruskala</a> - znalezienie Minimalnego Drzewa Opinającego (MST) dla ważonego nieukierunkowanego wykresu</li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Algorytm Dijkstry</a> - znajdowanie najkrótszej ścieżki z pojedynczego źródła w grafie</li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Algorytm Bellmana-Forda</a> - znajdowanie najkrótszych ścieżek do wszystkich wierzchołków wykresu z jednego wierzchołka</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Algorytm Floyd-Warshalla</a> - znajdź najkrótsze ścieżki między wszystkimi parami wierzchołków</li>
<li><code>A</code> <a href="src/algorithms/graph/detect-cycle">Detect Cycle</a> - zarówno dla wykresów skierowanych, jak i nieukierunkowanych(wersje oparte na DFS i Rozłączny Zestaw)</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Algorytm Prima</a> - znalezienie Minimalnego Drzewa Opinającego (MST) dla ważonego nieukierunkowanego wykresu</li>
<li><code>A</code> <a href="src/algorithms/graph/topological-sorting">Sortowanie Topologiczne</a> - metoda DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/articulation-points">Punkty Artykulacji</a> - Algorytm Tarjana (oparty o DFS)</li>
<li><code>A</code> <a href="src/algorithms/graph/bridges">Mosty</a> - Oparty na algorytmie DFS</li>
<li><code>A</code> <a href="src/algorithms/graph/eulerian-path">Ścieżka Euleriana i Obwód Euleriana</a> - Algorytm Fleurya - Odwiedź każdą krawędź dokładnie raz</li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Cykl Hamiltoniana</a> - Odwiedź każdy wierzchołek dokładnie raz</li>
<li><code>A</code> <a href="src/algorithms/graph/strongly-connected-components">Silnie Połączone Komponenty</a> - Algorytm Kosaraja</li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Travelling Salesman Problem</a> - najkrótsza ścieżka która odwiedza każde miasto i wraca miasta początkującego</li>
</ul></li>
<li><strong>Niezkategorizowane</strong>
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Wieża Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/square-matrix-rotation">Kwadratowa Matryca Obrotu</a> - algorytm w miejscu</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a> - cofanie, dynamiczne programowanie (od góry do dołu + od dołu do góry) i przykłady chciwego</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unikatowe Ścieżki</a> - cofanie, dynamiczne programowanie i przykłady oparte na Trójkącie Pascala</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">Problem N-Queens</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Knight’s Tour</a></li>
</ul></li>
</ul>
<h3 id="algorytmy-według-paradygmatu">Algorytmy według paradygmatu</h3>
<p>Paradygmat algorytmiczny jest ogólną metodą lub podejściem, które jest podstawą projektowania klasy algorytmów. Jest abstrakcją wyższą niż pojęcie algorytmu, podobnie jak algorytm jest abstrakcją wyższą niż program komputerowy.</p>
<ul>
<li><strong>Metoda Siłowa</strong> - Sprawdza wszystkie możliwosci i wybiera najlepsze rozwiązanie.
<ul>
<li><code>B</code> <a href="src/algorithms/search/linear-search">Wyszukiwanie Liniowe</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maksymalna Podtablica</a></li>
<li><code>A</code> <a href="src/algorithms/graph/travelling-salesman">Problem z Podróżującym Sprzedawcą</a> - najkrótsza możliwa trasa, która odwiedza każde miasto i wraca do miasta początkowego</li>
</ul></li>
<li><strong>Chciwy</strong> - wybierz najlepszą opcję w obecnym czasie, bez względu na przyszłość
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">Niezwiązany Problem Knapsacka</a></li>
<li><code>A</code> <a href="src/algorithms/graph/dijkstra">Algorytm Dijkstry</a> - znalezienie najkrótszej ścieżki do wszystkich wierzchołków grafu</li>
<li><code>A</code> <a href="src/algorithms/graph/prim">Algorytm Prima</a> - znalezienie Minimalnego Drzewa Opinającego (MST) dla ważonego nieukierunkowanego wykresu</li>
<li><code>A</code> <a href="src/algorithms/graph/kruskal">Algorytm Kruskala</a> - znalezienie Minimalnego Drzewa Opinającego (MST) dla ważonego nieukierunkowanego wykresu</li>
</ul></li>
<li><strong>Dziel i Zwyciężaj</strong> - podziel problem na mniejsze części, a następnie rozwiąż te części
<ul>
<li><code>B</code> <a href="src/algorithms/search/binary-search">Wyszukiwanie Binarne</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/hanoi-tower">Wieża Hanoi</a></li>
<li><code>B</code> <a href="src/algorithms/math/pascal-triangle">Trójkąt Pascala</a></li>
<li><code>B</code> <a href="src/algorithms/math/euclidean-algorithm">Algorytm Euclideana</a> - obliczyć Największy Wspólny Dzielnik(GCD)</li>
<li><code>B</code> <a href="src/algorithms/sorting/merge-sort">Sortowanie przez scalanie</a></li>
<li><code>B</code> <a href="src/algorithms/sorting/quick-sort">Szybkie Sortowanie</a></li>
<li><code>B</code> <a href="src/algorithms/tree/depth-first-search">Drzewo Przeszukiwania W Głąb</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/graph/depth-first-search">Graf Przeszukiwania W Głąb</a> (DFS)</li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>A</code> <a href="src/algorithms/sets/permutations">Permutacje</a> (z albo bez powtórzeń)</li>
<li><code>A</code> <a href="src/algorithms/sets/combinations">Kombinacje</a> (z albo bez powtórzeń)</li>
</ul></li>
<li><strong>Programowanie Dynamiczne</strong> - zbuduj rozwiązanie, korzystając z wcześniej znalezionych podrzędnych rozwiązań
<ul>
<li><code>B</code> <a href="src/algorithms/math/fibonacci">Ciąg Fibonacciego</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unikatowe Scieżki</a></li>
<li><code>A</code> <a href="src/algorithms/string/levenshtein-distance">Dystans Levenshteina</a> - minimalna odległość edycji między dwiema sekwencjami</li>
<li><code>A</code> <a href="src/algorithms/sets/longest-common-subsequence">Najdłuższa Wspólna Podsekwencja</a> (LCS)</li>
<li><code>A</code> <a href="src/algorithms/string/longest-common-substring">Najdłuższa Wspólna Podłańcucha</a></li>
<li><code>A</code> <a href="src/algorithms/sets/longest-increasing-subsequence">Najdłuższa Wzrostająca Podsekwencja</a></li>
<li><code>A</code> <a href="src/algorithms/sets/shortest-common-supersequence">Najkrótsza Wspólna Supersekwencja</a></li>
<li><code>A</code> <a href="src/algorithms/sets/knapsack-problem">0/1 Problem Knapsacka</a></li>
<li><code>A</code> <a href="src/algorithms/math/integer-partition">Partycja Całkowita</a></li>
<li><code>A</code> <a href="src/algorithms/sets/maximum-subarray">Maksymalne Podtablice</a></li>
<li><code>A</code> <a href="src/algorithms/graph/bellman-ford">Algorytm Bellman-Forda</a> - znalezienie najkrótszej ścieżki wszystkich wierzchołków wykresu</li>
<li><code>A</code> <a href="src/algorithms/graph/floyd-warshall">Algorytm Floyd-Warshalla</a> - znajdź najkrótsze ścieżki między wszystkimi parami wierzchołków</li>
<li><code>A</code> <a href="src/algorithms/string/regular-expression-matching">Dopasowanie Wyrażeń Regularnych</a></li>
</ul></li>
<li><strong>Algorytm z nawrotami</strong> - podobny do metody siłowej, próbuje wygenerować wszystkie możliwe rozwiązania, jednak za każdym razem generujesz następne rozwiązanie które testujesz jeżeli zaspokaja wszystkie warunki, tylko wtedy generuje kolejne rozwiązania. W innym wypadku, cofa sie, i podąża inna ścieżka znaleźenia rozwiązania. Zazwyczaj, używane jest przejście przez Przeszukiwania W Głąb(DFS) przestrzeni stanów.
<ul>
<li><code>B</code> <a href="src/algorithms/uncategorized/jump-game">Jump Game</a></li>
<li><code>B</code> <a href="src/algorithms/uncategorized/unique-paths">Unikatowe Scieżki</a></li>
<li><code>A</code> <a href="src/algorithms/graph/hamiltonian-cycle">Cykl Hamiltoniana</a> - Odwiedź każdy wierzchołek dokładnie raz</li>
<li><code>A</code> <a href="src/algorithms/uncategorized/n-queens">Problem N-Queens</a></li>
<li><code>A</code> <a href="src/algorithms/uncategorized/knight-tour">Knight’s Tour</a></li>
<li><code>A</code> <a href="src/algorithms/sets/combination-sum">Zestaw Sumy</a> - znajduje wszystkie zestawy które tworzą określoną sumę</li>
</ul></li>
<li><strong>Metoda Podziału i Ograniczeń</strong> - Pamięta o niskonakładowym rozwiązaniu znalezionym na każdym etapie szukania nawrotu, używa kosztu niskonakładowego kosztu, które dotychczas zostało znalezione jako niska granica najmniejszego kosztu do rozwiązanie problemu, aby odrzucić cząstkowe rozwiązania o kosztach większych niż niskonakładowe rozwiązanie znalezione do tej pory. Zazwyczan trajektoria BFS, w połączeniu z trajektorią Przeszukiwania W Głąb (DFS) drzewa przestrzeni stanów jest użyte.</li>
</ul>
<h2 id="jak-używać-repozytorium">Jak używać repozytorium</h2>
<p><strong>Zainstaluj wszystkie zależnosci</strong></p>
<pre><code>npm install</code></pre>
<p><strong>Uruchom ESLint</strong></p>
<p>Możesz to uruchomić aby sprawdzić jakość kodu.</p>
<pre><code>npm run lint</code></pre>
<p><strong>Uruchom wszystkie testy</strong></p>
<pre><code>npm test</code></pre>
<p><strong>Uruchom testy używając określonej nazwy</strong></p>
<pre><code>npm test -- &#39;LinkedList&#39;</code></pre>
<p><strong>Playground</strong></p>
<p>Możesz pociwiczyć ze strukturą danych i algorytmami w <code>./src/playground/playground.js</code> zakartotekuj i napisz testy do tego w <code>./src/playground/__test__/playground.test.js</code>.</p>
<p>Następnie uruchom następującą komendę w celu przetestowania czy twoje kod działa według oczekiwań:</p>
<pre><code>npm test -- &#39;playground&#39;</code></pre>
<h2 id="pomocne-informacje">Pomocne informacje</h2>
<h3 id="źródła">Źródła</h3>
<p><a href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8">â–¶ Struktury Danych i Algorytmy na YouTube</a></p>
<h3 id="big-o-notacja">Big O Notacja</h3>
<p>Kolejność wzrastania algorytmów według Big O notacji.</p>
<figure>
<img src="./assets/big-o-graph.png" alt="Big O grafy" /><figcaption>Big O grafy</figcaption>
</figure>
<p>Źródło: <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p>
<p>Poniżej umieszczamy listę najbardziej używanych Big O notacji i ich porównania wydajności do róznych rozmiarów z wprowadzonych danych.</p>
<table>
<colgroup>
<col style="width: 14%" />
<col style="width: 27%" />
<col style="width: 28%" />
<col style="width: 29%" />
</colgroup>
<thead>
<tr class="header">
<th>Big O notacja</th>
<th>Obliczenia na 10 elementów</th>
<th>Obliczenia na 100 elementów</th>
<th>Obliczenia na 1000 elementów</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>O(1)</strong></td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr class="even">
<td><strong>O(log N)</strong></td>
<td>3</td>
<td>6</td>
<td>9</td>
</tr>
<tr class="odd">
<td><strong>O(N)</strong></td>
<td>10</td>
<td>100</td>
<td>1000</td>
</tr>
<tr class="even">
<td><strong>O(N log N)</strong></td>
<td>30</td>
<td>600</td>
<td>9000</td>
</tr>
<tr class="odd">
<td><strong>O(N^2)</strong></td>
<td>100</td>
<td>10000</td>
<td>1000000</td>
</tr>
<tr class="even">
<td><strong>O(2^N)</strong></td>
<td>1024</td>
<td>1.26e+29</td>
<td>1.07e+301</td>
</tr>
<tr class="odd">
<td><strong>O(N!)</strong></td>
<td>3628800</td>
<td>9.3e+157</td>
<td>4.02e+2567</td>
</tr>
</tbody>
</table>
<h3 id="złożoność-operacji-struktury-danych">Złożoność operacji struktury danych</h3>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 9%" />
<col style="width: 6%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Struktura Danych</th>
<th style="text-align: center;">Dostęp</th>
<th style="text-align: center;">Szukaj</th>
<th style="text-align: center;">Umieszczanie</th>
<th style="text-align: center;">Usuwanie</th>
<th style="text-align: left;">Komentarze</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Szereg</strong></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Sterta</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Kolejka</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Lista Powiązana</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Tablica funkcji mieszanej</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: left;">W wypadku idealnej funkcji skrótu koszt mógłby sie równać O(1)</td>
</tr>
<tr class="even">
<td><strong>Binarne Drzewo Poszukiwań</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n</td>
<td style="text-align: left;">W przypadku zrównoważonych kosztów drzew byłoby O(log(n))</td>
</tr>
<tr class="odd">
<td><strong>B-Drzewo</strong></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Drzewa czerwono-czarne</strong></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>AVL Drzewo</strong></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Filtr Blooma</strong></td>
<td style="text-align: center;">-</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-</td>
<td style="text-align: left;">Fałszywe dotatnie są możliwe podczas wyszukiwania</td>
</tr>
</tbody>
</table>
<h3 id="sortowanie-tablic-złożoności-algorytmów">Sortowanie Tablic Złożoności Algorytmów</h3>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 6%" />
<col style="width: 13%" />
<col style="width: 14%" />
<col style="width: 3%" />
<col style="width: 5%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>Nazwa</th>
<th style="text-align: center;">Najlepszy</th>
<th style="text-align: center;">Średni</th>
<th style="text-align: center;">Najgorszy</th>
<th style="text-align: center;">Pamięć</th>
<th style="text-align: center;">Stabilność</th>
<th style="text-align: left;">Komentarze</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>Sortowanie bąbelkowe</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Sortowanie przez wstawianie</strong></td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Sortowanie przez wybieranie</strong></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">No</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Sortowanie przez kopcowanie</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">No</td>
<td style="text-align: left;"></td>
</tr>
<tr class="odd">
<td><strong>Sortowanie przez scalanie</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Szybkie sortowanie</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">n<sup>2</sup></td>
<td style="text-align: center;">log(n)</td>
<td style="text-align: center;">No</td>
<td style="text-align: left;">Szybkie sortowanie jest zazwyczaj robione w miejsce O(log(n)) stosu przestrzeni</td>
</tr>
<tr class="odd">
<td><strong>Sortowanie Shella</strong></td>
<td style="text-align: center;">n log(n)</td>
<td style="text-align: center;">zależy od luki w układzie</td>
<td style="text-align: center;">n (log(n))<sup>2</sup></td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">No</td>
<td style="text-align: left;"></td>
</tr>
<tr class="even">
<td><strong>Sortowanie przez zliczanie</strong></td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">n + r</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: left;">r - największy numer w tablicy</td>
</tr>
<tr class="odd">
<td><strong>Sortowanie Radix</strong></td>
<td style="text-align: center;">n * k</td>
<td style="text-align: center;">n * k</td>
<td style="text-align: center;">n * k</td>
<td style="text-align: center;">n + k</td>
<td style="text-align: center;">Yes</td>
<td style="text-align: left;">k -długość najdłuższego klucza</td>
</tr>
</tbody>
</table>
<blockquote>
<p>ℹ️ A few more <a href="https://trekhleb.dev/projects/">projects</a> and <a href="https://trekhleb.dev/blog/">articles</a> about JavaScript and algorithms on <a href="https://trekhleb.dev">trekhleb.dev</a></p>
</blockquote>
</body>
</html>
