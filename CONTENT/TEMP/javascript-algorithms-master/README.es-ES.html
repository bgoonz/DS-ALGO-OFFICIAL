<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>README.es-ES</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="algoritmos-y-estructuras-de-datos-en-javascript">
      Algoritmos y Estructuras de Datos en JavaScript
    </h1>
    <p>
      <a
        href="https://github.com/trekhleb/javascript-algorithms/actions?query=workflow%3ACI+branch%3Amaster"
        ><img
          src="https://github.com/trekhleb/javascript-algorithms/workflows/CI/badge.svg"
          alt="CI"
      /></a>
      <a href="https://codecov.io/gh/trekhleb/javascript-algorithms"
        ><img
          src="https://codecov.io/gh/trekhleb/javascript-algorithms/branch/master/graph/badge.svg"
          alt="codecov"
      /></a>
    </p>
    <p>
      Este repositorio contiene ejemplos basados en JavaScript de muchos
      algoritmos y estructuras de datos populares.
    </p>
    <p>
      Cada algoritmo y estructura de datos tiene su propio LÉAME con
      explicaciones relacionadas y enlaces para lecturas adicionales (incluyendo
      algunas a vídeos de YouTube).
    </p>
    <p>
      <em>Léelo en otros idiomas:</em>
      <a href="https://github.com/trekhleb/javascript-algorithms/"
        ><em>English</em></a
      >, <a href="README.zh-CN.md"><em>简体中文</em></a
      >, <a href="README.zh-TW.md"><em>繁體中文</em></a
      >, <a href="README.ko-KR.md"><em>한국어</em></a
      >, <a href="README.ja-JP.md"><em>日本語</em></a
      >, <a href="README.pl-PL.md"><em>Polski</em></a
      >, <a href="README.fr-FR.md"><em>Français</em></a
      >, <a href="README.pt-BR.md"><em>Português</em></a
      >, <a href="README.ru-RU.md"><em>Русский</em></a
      >, <a href="README.tr-TR.md"><em>Türk</em></a
      >, <a href="README.it-IT.md"><em>Italiana</em></a
      >, <a href="README.id-ID.md"><em>Bahasa Indonesia</em></a
      >, <a href="README.uk-UA.md"><em>Українська</em></a
      >, <a href="README.ar-AR.md"><em>Arabic</em></a
      >, <a href="README.de-DE.md"><em>Deutsch</em></a>
    </p>
    <p>
      <em
        >☝ Nótese que este proyecto está pensado con fines de aprendizaje e
        investigación, y <strong>no</strong> para ser usado en producción.</em
      >
    </p>
    <h2 id="estructuras-de-datos">Estructuras de Datos</h2>
    <p>
      Una estructura de datos es una forma particular de organizar y almacenar
      datos en un ordenador para que puedan accederse y modificarse de forma
      eficiente. Más concretamente, una estructura de datos es un conjunto de
      valores de datos, las relaciones entre ellos y las funciones u operaciones
      que se pueden aplicar a los datos.
    </p>
    <p><code>P</code> - Principiante, <code>A</code> - Avanzado</p>
    <ul>
      <li>
        <code>P</code>
        <a href="src/data-structures/linked-list">Lista enlazada</a>
      </li>
      <li>
        <code>P</code>
        <a href="src/data-structures/doubly-linked-list"
          >Lista doblemente enlazada</a
        >
      </li>
      <li><code>P</code> <a href="src/data-structures/queue">Cola</a></li>
      <li><code>P</code> <a href="src/data-structures/stack">Pila</a></li>
      <li>
        <code>P</code> <a href="src/data-structures/hash-table">Tabla hash</a>
      </li>
      <li>
        <code>P</code> <a href="src/data-structures/heap">Heap</a> - versiones
        máx y mín
      </li>
      <li>
        <code>P</code>
        <a href="src/data-structures/priority-queue">Cola de prioridad</a>
      </li>
      <li><code>A</code> <a href="src/data-structures/trie">Trie</a></li>
      <li>
        <code>A</code> <a href="src/data-structures/tree">Árbol</a>
        <ul>
          <li>
            <code>A</code>
            <a href="src/data-structures/tree/binary-search-tree"
              >Árbol de búsqueda binaria</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/data-structures/tree/avl-tree">Árbol AVL</a>
          </li>
          <li>
            <code>A</code>
            <a href="src/data-structures/tree/red-black-tree"
              >Árbol Rojo-Negro</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/data-structures/tree/segment-tree"
              >Árbol de segmentos</a
            >
            - con ejemplos de consultas de rango mín/máx/suma
          </li>
          <li>
            <code>A</code>
            <a href="src/data-structures/tree/fenwick-tree">Árbol de Fenwick</a>
            (Árbol binario indexado)
          </li>
        </ul>
      </li>
      <li>
        <code>A</code> <a href="src/data-structures/graph">Grafo</a> (dirigido y
        no dirigido)
      </li>
      <li>
        <code>A</code>
        <a href="src/data-structures/disjoint-set">Conjuntos disjuntos</a>
      </li>
      <li>
        <code>A</code>
        <a href="src/data-structures/bloom-filter">Filtro de Bloom</a>
      </li>
    </ul>
    <h2 id="algoritmos">Algoritmos</h2>
    <p>
      Un algoritmo es una especificación inequívoca de cómo resolver una clase
      de problemas. Es un conjunto de reglas que definen con precisión una
      secuencia de operaciones.
    </p>
    <p><code>P</code> - Principiante, <code>A</code> - Avanzado</p>
    <h3 id="algoritmos-por-tema">Algoritmos por Tema</h3>
    <ul>
      <li>
        <strong>Matemáticas</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/bits">Manipulación de bits</a> -
            asignar/obtener/actualizar/limpiar bits, multiplicación/división por
            dos, hacer negativo, etc.
          </li>
          <li>
            <code>P</code> <a href="src/algorithms/math/factorial">Factorial</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/fibonacci">Número de Fibonacci</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/primality-test"
              >Prueba de primalidad</a
            >
            (método de división de prueba)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/euclidean-algorithm"
              >Algoritmo de Euclides</a
            >
            - calcular el Máximo común divisor (MCD)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/least-common-multiple"
              >Mínimo común múltiplo</a
            >
            (MCM)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/sieve-of-eratosthenes"
              >Criba de Eratóstenes</a
            >
            - encontrar todos los números primos hasta un límite dado
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/is-power-of-two"
              >Es una potencia de dos?</a
            >
            - comprobar si el número es una potencia de dos (algoritmos ingenuos
            y de bits)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/pascal-triangle"
              >Triángulo de Pascal</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/complex-number">Números complejos</a> -
            números complejos y operaciones con ellos
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/radian">Radianes &amp; Grados</a> -
            conversión de radianes a grados y viceversa
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/fast-powering"
              >Exponenciación rápida</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/math/integer-partition">Partición entera</a>
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/math/liu-hui">Algortimo π de Liu Hui</a> -
            aproximar el cálculo de π basado en polígonos de N lados
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/math/fourier-transform"
              >Transformada discreta de Fourier</a
            >
            - descomponer una función de tiempo (señal) en las frecuencias que
            la componen
          </li>
        </ul>
      </li>
      <li>
        <strong>Conjuntos</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/sets/cartesian-product"
              >Producto cartesiano</a
            >
            - producto de múltiples conjuntos
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sets/fisher-yates"
              >Permutación de Fisher–Yates</a
            >
            - permutación aleatoria de una secuencia finita
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/power-set">Conjunto potencia</a> -
            todos los subconjuntos de un conjunto
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/permutations">Permutaciones</a> (con y
            sin repeticiones)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/combinations">Combinaciones</a> (con y
            sin repeticiones)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/longest-common-subsequence"
              >Subsecuencia común más larga</a
            >
            (LCS)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/longest-increasing-subsequence"
              >Subsecuencia creciente más larga</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/shortest-common-supersequence"
              >Supersecuencia común más corta</a
            >
            (SCS)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/knapsack-problem"
              >Problema de la mochila</a
            >
            - “0/1” y “sin límite”
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/maximum-subarray">Máximo subarreglo</a>
            - versiones de “fuerza bruta” y “programación dinámica” (de Kadane)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/combination-sum">Suma combinada</a> -
            encuentra todas las combinaciones que forman una suma específica
          </li>
        </ul>
      </li>
      <li>
        <strong>Cadenas de caracteres</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/string/hamming-distance"
              >Distancia de Hamming</a
            >
            - número de posiciones en las que los símbolos son diferentes
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/levenshtein-distance"
              >Distancia de Levenshtein</a
            >
            - distancia mínima de edición entre dos secuencias
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/knuth-morris-pratt"
              >Algoritmo Knuth-Morris-Pratt</a
            >
            (Algoritmo KMP) - búsqueda de subcadenas (coincidencia de patrones)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/z-algorithm">Algoritmo Z</a> -
            búsqueda de subcadenas (coincidencia de patrones)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/rabin-karp"
              >Algoritmo de Rabin Karp</a
            >
            - búsqueda de subcadenas
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/longest-common-substring"
              >Subcadena común más larga</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/regular-expression-matching"
              >Coincidencia por expresiones regulares</a
            >
          </li>
        </ul>
      </li>
      <li>
        <strong>Búsquedas</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/search/linear-search">Búsqueda lineal</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/search/jump-search">Búsqueda de salto</a> (o
            Búsqueda de bloque) - búsqueda en una lista ordenada
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/search/binary-search">Búsqueda binaria</a> -
            búsqueda en una lista ordenada
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/search/interpolation-search"
              >Búsqueda por interpolación</a
            >
            - búsqueda en una lista ordenada uniformemente distribuida
          </li>
        </ul>
      </li>
      <li>
        <strong>Ordenamiento</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/bubble-sort"
              >Ordenamiento de burbuja</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/selection-sort"
              >Ordenamiento por selección</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/insertion-sort"
              >Ordenamiento por inserción</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/heap-sort">Ordenamiento por Heap</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/merge-sort"
              >Ordenamiento por mezcla</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/quick-sort">Quicksort</a> -
            implementaciones in situ y no in situ
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/shell-sort">Shellsort</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/counting-sort"
              >Ordenamiento por cuentas</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/radix-sort">Ordenamiento Radix</a>
          </li>
        </ul>
      </li>
      <li>
        <strong>Listas enlazadas</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/linked-list/traversal">Recorrido directo</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/linked-list/reverse-traversal"
              >Recorrido inverso</a
            >
          </li>
        </ul>
      </li>
      <li>
        <strong>Árboles</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/tree/depth-first-search"
              >Búsqueda en profundidad</a
            >
            (DFS)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/tree/breadth-first-search"
              >Búsqueda en anchura</a
            >
            (BFS)
          </li>
        </ul>
      </li>
      <li>
        <strong>Grafos</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/graph/depth-first-search"
              >Búsqueda en profundidad</a
            >
            (DFS)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/graph/breadth-first-search"
              >Búsqueda en anchura</a
            >
            (BFS)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/graph/kruskal">Algoritmo de Kruskal</a> -
            encontrar el árbol de cubrimiento mínimo (MST) para un grafo no
            dirigido ponderado
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/dijkstra">Algoritmo de Dijkstra</a> -
            encontrar los caminos más cortos a todos los vértices del grafo
            desde un solo vértice
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/bellman-ford"
              >Algoritmo de Bellman-Ford</a
            >
            - encontrar los caminos más cortos a todos los vértices del grafo
            desde un solo vértice
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/floyd-warshall"
              >Algortimo de Floyd-Warshall</a
            >
            - encontrar los caminos más cortos entre todos los pares de vértices
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/detect-cycle">Detectar ciclos</a> -
            para grafos dirigidos y no dirigidos (versiones basadas en DFS y
            conjuntos disjuntos)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/prim">Algoritmo de Prim</a> -
            encontrar el árbol de cubrimiento mínimo (MST) para un grafo no
            dirigido ponderado
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/topological-sorting"
              >Ordenamiento topológico</a
            >
            - método DFS
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/articulation-points"
              >Puntos de articulación</a
            >
            - algoritmo de Tarjan (basado en DFS)
          </li>
          <li>
            <code>A</code> <a href="src/algorithms/graph/bridges">Puentes</a> -
            algoritmo basado en DFS
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/eulerian-path"
              >Camino euleriano y circuito euleriano</a
            >
            - algoritmo de Fleury - visitar cada arista exactamente una vez
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/hamiltonian-cycle"
              >Ciclo hamiltoniano</a
            >
            - visitar cada vértice exactamente una vez
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/strongly-connected-components"
              >Componentes fuertemente conexos</a
            >
            - algoritmo de Kosaraju
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/travelling-salesman"
              >Problema del viajante</a
            >
            - la ruta más corta posible que visita cada ciudad y vuelve a la
            ciudad de origen
          </li>
        </ul>
      </li>
      <li>
        <strong>Criptografia</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/cryptography/polynomial-hash"
              >Hash polinomial</a
            >
            - función de hash rodante basada en polinomio
          </li>
        </ul>
      </li>
      <li>
        <strong>Sin categoría</strong>
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/hanoi-tower"
              >Torre de Hanói</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/square-matrix-rotation"
              >Rotación de matriz cuadrada</a
            >
            - algoritmo in situ
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/jump-game"
              >Juego de los saltos</a
            >
            - ejemplos de backtracking, programación dinámica (de arriba hacia
            abajo + de abajo hacia arriba) y voraces
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/unique-paths"
              >Caminos únicos</a
            >
            - ejemplos de backtracking, programación dinámica y basados en el
            Triángulo de Pascal
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/rain-terraces"
              >Terrazas pluviales</a
            >
            - el problema de la retención del agua de lluvia (programación
            dinámica y fuerza bruta)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/uncategorized/n-queens"
              >Problema de las N Reinas</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/uncategorized/knight-tour"
              >Problema del caballo (Knight tour)</a
            >
          </li>
        </ul>
      </li>
    </ul>
    <h3 id="algoritmos-por-paradigma">Algoritmos por paradigma</h3>
    <p>
      Un paradigma algorítmico es un método o enfoque genérico que subyace al
      diseño de una clase de algoritmos. Es una abstracción superior a la noción
      de algoritmo, del mismo modo que un algoritmo es una abstracción superior
      a un programa de ordenador.
    </p>
    <ul>
      <li>
        <strong>Fuerza Bruta</strong> - mira todas las posibilidades y
        selecciona la mejor solución
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/search/linear-search">Búsqueda lineal</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/rain-terraces"
              >Terrazas pluviales</a
            >
            - el problema de la retención del agua de lluvia
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/maximum-subarray">Máximo subarreglo</a>
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/travelling-salesman"
              >Problema del viajante</a
            >
            - la ruta más corta posible que visita cada ciudad y vuelve a la
            ciudad de origen
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/math/fourier-transform"
              >Transformada discreta de Fourier</a
            >
            - descomponer una función de tiempo (señal) en las frecuencias que
            la componen
          </li>
        </ul>
      </li>
      <li>
        <strong>Voraces</strong> - escoge la mejor opción en el momento actual,
        sin ninguna consideración sobre el futuro
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/jump-game"
              >Juego de los saltos</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/knapsack-problem"
              >Problema de la mochila sin límite</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/dijkstra">Algoritmo de Dijkstra</a> -
            encontrar los caminos más cortos a todos los vértices del grafo
            desde un solo vértice
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/prim">Algortimo de Prim</a> -
            encontrar el árbol de cubrimiento mínimo (MST) para un grafo no
            dirigido ponderado
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/kruskal">Algoritmo de Kruskal</a> -
            encontrar el árbol de cubrimiento mínimo (MST) para un grafo no
            dirigido ponderado
          </li>
        </ul>
      </li>
      <li>
        <strong>Divide y Vencerás</strong> - divide el problema en partes más
        pequeñas y luego resuelve esas partes
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/search/binary-search">Búsqueda binaria</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/hanoi-tower"
              >Torre de Hanói</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/pascal-triangle"
              >Triángulo de Pascal</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/euclidean-algorithm"
              >Algoritmo de Euclides</a
            >
            - calcular el Máximo Común Divisor (MCD)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/merge-sort"
              >Ordenamiento por mezcla</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sorting/quick-sort">Quicksort</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/tree/depth-first-search"
              >Búsqueda en profundidad (árboles)</a
            >
            - (DFS)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/graph/depth-first-search"
              >Búsqueda en profundidad (grafos)</a
            >
            - (DFS)
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/jump-game"
              >Juego de los saltos</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/fast-powering"
              >Exponenciación rápida</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/permutations">Permutaciones</a> - (con
            y sin repeticiones)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/combinations">Combinaciones</a> - (con
            y sin repeticiones)
          </li>
        </ul>
      </li>
      <li>
        <strong>Programación Dinámica</strong> - construye una solución usando
        sub-soluciones previamente encontradas
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/math/fibonacci">Número de Fibonacci</a>
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/jump-game"
              >Juego de los saltos</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/unique-paths"
              >Caminos únicos</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/rain-terraces"
              >Terrazas pluviales</a
            >
            - el problema de la retención del agua de lluvia
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/levenshtein-distance"
              >Distancia de Levenshtein</a
            >
            - distancia mínima de edición entre dos secuencias
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/longest-common-subsequence"
              >Subsecuencia común más larga</a
            >
            (LCS)
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/longest-common-substring"
              >Subcadena común más larga</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/longest-increasing-subsequence"
              >Subsecuencia creciente más larga</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/shortest-common-supersequence"
              >Supersecuencia común más corta</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/knapsack-problem"
              >Problema de la mochila 0/1</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/math/integer-partition">Partición entera</a>
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/maximum-subarray">Máximo subarreglo</a>
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/bellman-ford"
              >Algoritmo de Bellman-Ford</a
            >
            - encontrar los caminos más cortos a todos los vértices del grafo
            desde un solo vértice
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/floyd-warshall"
              >Algoritmo de Floyd-Warshall</a
            >
            - encontrar los caminos más cortos entre todos los pares de vértices
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/string/regular-expression-matching"
              >Coincidencia por expresiones regulares</a
            >
          </li>
        </ul>
      </li>
      <li>
        <strong>De Retorceso (Backtracking)</strong> - De manera similar a la
        fuerza bruta, trata de generar todas las soluciones posibles, pero cada
        vez que genere la siguiente solución, comprueba si cumple con todas las
        condiciones, y sólo entonces continúa generando soluciones posteriores.
        De lo contrario, retrocede y sigue un camino diferente para encontrar
        una solución. Normalmente se utiliza un recorrido en profundidad (DFS)
        del espacio de estados.
        <ul>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/jump-game"
              >Juego de los saltos</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/uncategorized/unique-paths"
              >Caminos únicos</a
            >
          </li>
          <li>
            <code>P</code>
            <a href="src/algorithms/sets/power-set">Conjunto potencia</a> -
            todos los subconjuntos de un conjunto
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/graph/hamiltonian-cycle"
              >Ciclo hamiltoniano</a
            >
            - visitar cada vértice exactamente una vez
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/uncategorized/n-queens"
              >Problema de las N Reinas</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/uncategorized/knight-tour"
              >Problema del caballo (Knight tour)</a
            >
          </li>
          <li>
            <code>A</code>
            <a href="src/algorithms/sets/combination-sum">Suma combinada</a> -
            encuentra todas las combinaciones que forman una suma específica
          </li>
        </ul>
      </li>
      <li>
        <strong>Ramas y Limites</strong> - recuerda la solución de menor costo
        encontrada en cada etapa de la búsqueda de rastreo, y utilizar el costo
        de la solución de menor costo encontrada hasta el momento como un límite
        inferior del costo de una solución de menor costo para el problema, a
        fin de descartar soluciones parciales con costos mayores que la solución
        de menor costo encontrada hasta el momento. Normalmente se utiliza un
        recorrido BFS en combinación con un recorrido DFS del árbol del espacio
        de estados.
      </li>
    </ul>
    <h2 id="cómo-usar-este-repositorio">Cómo usar este repositorio</h2>
    <p><strong>Instalar las dependencias</strong></p>
    <pre><code>npm install</code></pre>
    <p><strong>Correr ESLint</strong></p>
    <p>Es posible que desee ejecutarlo para comprobar la calidad del código.</p>
    <pre><code>npm run lint</code></pre>
    <p><strong>Correr los tests</strong></p>
    <pre><code>npm test</code></pre>
    <p><strong>Correr tests por nombre</strong></p>
    <pre><code>npm test -- &#39;LinkedList&#39;</code></pre>
    <p><strong>Campo de juegos</strong></p>
    <p>
      Puede jugar con estructuras de datos y algoritmos en el archivo
      <code>./src/playground/playground.js</code> y escribir pruebas para ello
      en <code>./src/playground/__test__/playground.test.js</code>.
    </p>
    <p>
      A continuación, simplemente ejecute el siguiente comando para comprobar si
      el código funciona como se espera:
    </p>
    <pre><code>npm test -- &#39;playground&#39;</code></pre>
    <h2 id="información-útil">Información útil</h2>
    <h3 id="refrencias">Refrencias</h3>
    <p>
      <a
        href="https://www.youtube.com/playlist?list=PLLXdhg_r2hKA7DPDsunoDZ-Z769jWn4R8"
        >▶ Estructuras de datos y algoritmos en YouTube</a
      >
    </p>
    <h3 id="notación-o-grande">Notación O Grande</h3>
    <p>
      Orden de crecimiento de los algoritmos especificados en la notación O
      grande.
    </p>
    <figure>
      <img src="./assets/big-o-graph.png" alt="Gráficas de Notación O grande" />
      <figcaption>Gráficas de Notación O grande</figcaption>
    </figure>
    <p>Fuente: <a href="http://bigocheatsheet.com/">Big O Cheat Sheet</a>.</p>
    <p>
      A continuación se muestra la lista de algunas de las notaciones de Big O
      más utilizadas y sus comparaciones de rendimiento frente a diferentes
      tamaños de los datos de entrada.
    </p>
    <table>
      <colgroup>
        <col style="width: 17%" />
        <col style="width: 26%" />
        <col style="width: 27%" />
        <col style="width: 28%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th>Notación O grande</th>
          <th>Cálculos para 10 elementos</th>
          <th>Cálculos para 100 elementos</th>
          <th>Cálculos para 1000 elementos</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><strong>O(1)</strong></td>
          <td>1</td>
          <td>1</td>
          <td>1</td>
        </tr>
        <tr class="even">
          <td><strong>O(log N)</strong></td>
          <td>3</td>
          <td>6</td>
          <td>9</td>
        </tr>
        <tr class="odd">
          <td><strong>O(N)</strong></td>
          <td>10</td>
          <td>100</td>
          <td>1000</td>
        </tr>
        <tr class="even">
          <td><strong>O(N log N)</strong></td>
          <td>30</td>
          <td>600</td>
          <td>9000</td>
        </tr>
        <tr class="odd">
          <td><strong>O(N^2)</strong></td>
          <td>100</td>
          <td>10000</td>
          <td>1000000</td>
        </tr>
        <tr class="even">
          <td><strong>O(2^N)</strong></td>
          <td>1024</td>
          <td>1.26e+29</td>
          <td>1.07e+301</td>
        </tr>
        <tr class="odd">
          <td><strong>O(N!)</strong></td>
          <td>3628800</td>
          <td>9.3e+157</td>
          <td>4.02e+2567</td>
        </tr>
      </tbody>
    </table>
    <h3 id="complejidad-de-las-operaciones-de-estructuras-de-datos">
      Complejidad de las operaciones de estructuras de datos
    </h3>
    <table>
      <colgroup>
        <col style="width: 24%" />
        <col style="width: 5%" />
        <col style="width: 6%" />
        <col style="width: 7%" />
        <col style="width: 5%" />
        <col style="width: 50%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th>Estructura de Datos</th>
          <th style="text-align: center">Accesso</th>
          <th style="text-align: center">Busqueda</th>
          <th style="text-align: center">Inserción</th>
          <th style="text-align: center">Borrado</th>
          <th style="text-align: left">Comentarios</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><strong>Colección</strong></td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Stack</strong></td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="odd">
          <td><strong>Cola</strong></td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Lista enlazada</strong></td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="odd">
          <td><strong>Tabla hash</strong></td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: left">
            En caso de función hash perfecta los costos serían O(1)
          </td>
        </tr>
        <tr class="even">
          <td><strong>Búsqueda por Árbol binario</strong></td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n</td>
          <td style="text-align: left">
            En el caso de un árbol equilibrado, los costos serían O(log(n))
          </td>
        </tr>
        <tr class="odd">
          <td><strong>Árbol B</strong></td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Árbol Rojo-Negro</strong></td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="odd">
          <td><strong>Árbol AVL</strong></td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Filtro de Bloom</strong></td>
          <td style="text-align: center">-</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">-</td>
          <td style="text-align: left">
            Falsos positivos son posibles durante la búsqueda
          </td>
        </tr>
      </tbody>
    </table>
    <h3 id="complejidad-de-algoritmos-de-ordenamiento-de-arreglos">
      Complejidad de algoritmos de ordenamiento de arreglos
    </h3>
    <table>
      <colgroup>
        <col style="width: 17%" />
        <col style="width: 7%" />
        <col style="width: 19%" />
        <col style="width: 16%" />
        <col style="width: 4%" />
        <col style="width: 4%" />
        <col style="width: 29%" />
      </colgroup>
      <thead>
        <tr class="header">
          <th>Nombre</th>
          <th style="text-align: center">Mejor</th>
          <th style="text-align: center">Promedio</th>
          <th style="text-align: center">Pero</th>
          <th style="text-align: center">Memorya</th>
          <th style="text-align: center">Estable</th>
          <th style="text-align: left">Comentarios</th>
        </tr>
      </thead>
      <tbody>
        <tr class="odd">
          <td><strong>Ordenamiento de burbuja</strong></td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">Si</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Ordenamiento por inserción</strong></td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">Si</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="odd">
          <td><strong>Ordenamiento por selección</strong></td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">No</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Ordenamiento por Heap</strong></td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">No</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="odd">
          <td><strong>Ordenamiento por mezcla</strong></td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n</td>
          <td style="text-align: center">Si</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Quicksort</strong></td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">n<sup>2</sup></td>
          <td style="text-align: center">log(n)</td>
          <td style="text-align: center">No</td>
          <td style="text-align: left">
            Quicksort utiliza O(log(n)) de espacio en el stack
          </td>
        </tr>
        <tr class="odd">
          <td><strong>Shellsort</strong></td>
          <td style="text-align: center">n log(n)</td>
          <td style="text-align: center">depende de la secuencia de huecos</td>
          <td style="text-align: center">n (log(n))<sup>2</sup></td>
          <td style="text-align: center">1</td>
          <td style="text-align: center">No</td>
          <td style="text-align: left"></td>
        </tr>
        <tr class="even">
          <td><strong>Ordenamiento por cuentas</strong></td>
          <td style="text-align: center">n + r</td>
          <td style="text-align: center">n + r</td>
          <td style="text-align: center">n + r</td>
          <td style="text-align: center">n + r</td>
          <td style="text-align: center">Si</td>
          <td style="text-align: left">r - mayor número en el arreglo</td>
        </tr>
        <tr class="odd">
          <td><strong>Ordenamiento Radix</strong></td>
          <td style="text-align: center">n * k</td>
          <td style="text-align: center">n * k</td>
          <td style="text-align: center">n * k</td>
          <td style="text-align: center">n + k</td>
          <td style="text-align: center">Si</td>
          <td style="text-align: left">k - largo de la llave más larga</td>
        </tr>
      </tbody>
    </table>
    <blockquote>
      <p>
        ℹ️ A few more <a href="https://trekhleb.dev/projects/">projects</a> and
        <a href="https://trekhleb.dev/blog/">articles</a> about JavaScript and
        algorithms on <a href="https://trekhleb.dev">trekhleb.dev</a>
      </p>
    </blockquote>
  </body>
</html>
