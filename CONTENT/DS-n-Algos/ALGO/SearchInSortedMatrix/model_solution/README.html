<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>README</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="search-in-sorted-matrix-walkthrough">
      Search In Sorted Matrix Walkthrough
    </h1>
    <h2 id="understanding-the-problem">Understanding the Problem</h2>
    <p>
      The first thing that should be jumping at when reading the prompt for the
      problem is the fact that the rows and columns of the matrix are already
      sorted. Of course, we could iterate through every element in the matrix
      one by one, going from left to right and then top to bottom, checking
      every element to see if we’ve found the matching element. In the worst
      case, this would yield us a runtime of O(n * m) where n is the number of
      rows and m is the number of columns. If we had a square matrix where the
      number of rows and columns is the same, this would be the same as O(n^2).
      That solution would look something like this:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">def</span> search_in_sorted_matrix(matrix, target):</a>
<a class="sourceLine" id="cb1-2" title="2">    <span class="co"># iterate along each row</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matrix)):</a>
<a class="sourceLine" id="cb1-4" title="4">        <span class="co"># iterate along each column</span></a>
<a class="sourceLine" id="cb1-5" title="5">        <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(matrix[<span class="dv">0</span>])):</a>
<a class="sourceLine" id="cb1-6" title="6">            <span class="cf">if</span> matrix[row][col] <span class="op">==</span> target:</a>
<a class="sourceLine" id="cb1-7" title="7">                <span class="cf">return</span> [row, col]</a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="co"># we iterated through the whole matrix and didn&#39;t find the target</span></a>
<a class="sourceLine" id="cb1-9" title="9">    <span class="cf">return</span> (<span class="op">-</span><span class="dv">1</span>, <span class="dv">-1</span>)</a></code></pre>
    </div>
    <p>
      If our matrix was unsorted, this would most likely be the best we could
      do, since we don’t know anything about the order of the elements in an
      unsorted matrix. However, in this case, since the matrix is sorted, we can
      take advantage of this fact to achieve a more performant algorithm.
    </p>
    <h2 id="coming-up-with-a-strategy">Coming up with a Strategy</h2>
    <p>
      When we’re handed a problem where the data is already sorted, one of the
      first questions we should be asking is if we can utilize binary search in
      some way for this problem. The binary search algorithm is typically used
      on already-sorted or almost-sorted one-dimensional arrays. Can we utilize
      the same idea to search through a sorted matrix?
    </p>
    <p>
      To reiterate on the binary search algorithm, we start off by calculating
      the midpoint of the array we’re searching through, then we check to see if
      the midpoint element of the array is less than, equal to, or greater than
      our target element. If the midpoint element is equal to the target
      element, then great, we’re done! If the midpoint element is less than the
      target element, then we know, by virtue of the fact that the data is
      already sorted, that it must exist in the right half of the sorted array
      (if it exists in the array in the first place). Similarly, if the midpoint
      element is greater than the target element, then we know that the target
      element must exist in the left half of the sorted array (again, if it
      exists in the array in the first place).
    </p>
    <p>
      So how can we apply this idea to a sorted matrix? Let’s consider an
      example. Let’s say we have the following sorted matrix:
    </p>
    <pre><code>[
    [1,  4,  7,   12,  15,  997,  999],
    [2,  5,  19,  32,  35,  1001, 1007],
    [4,  8,  24,  34,  36,  1008, 1015],
    [40, 41, 42,  44,  45,  1018, 1020],
    [98, 99, 101, 104, 190, 1021, 1025],
]</code></pre>
    <p>
      How would we go about trying to find 41 in this sorted matrix? The binary
      search algorithm prescribes first finding the midpoint, so let’s try that
      with our matrix. In this example, the midpoint is the element in the
      middle column and middle row, which in this case is the element located at
      row 2 column 3, or 34. 41 is greater than 34. What does that tell us?
      Well, it tells us that if 41 exists in the matrix, it’s either in a column
      to the right of column 3, or it’s in a row lower than row 2. But how do we
      know in which dimension to continue searching from this point, rows or
      columns?
    </p>
    <p>
      With the information we currently have, it’s not really clear. In this
      case, perhaps starting at the midpoint of the matrix doesn’t work out so
      well as starting at the midpoint in a one-dimensional array. So if we’re
      not going to start in the midpoint, where should we start instead?
    </p>
    <p>
      What if we tried starting in one of the corners? Let’s try the northwest
      corner. The element there, 1, is less than 41. Ok, what does that tell us?
      Well, not much, since 41 could still be to the right of 1 or underneath
      it, since it’s larger. So that was even less helpful than starting at the
      midpoint.
    </p>
    <p>
      Ok, let’s try the northeast corner. The element there, 999, is larger than
      41, is located at coordinates [0, 6], row 0 and column 6. Now, we know
      that 41 must be in a column to the right of column 6, since every element
      directly underneath 999 is greater than it. Ok, let’s keep going. If we
      shift over one column to the left, we’re now at coordinates [0, 5], which
      is where 997 is located. Again, 997 is larger than 41, so we can continue
      shifting to the left since we know that 41 can’t be located directly
      underneath 997; all of those elements are larger than 997.
    </p>
    <p>
      Shifting over to the left one more time, we end up at coordinates [0, 4],
      where 15 is located. At this point, 15 is less than 41, so it could
      certainly be directly underneath 15 in column 4. But now we know that 41
      cannot be in this row, since it would have been between elements 15 and
      997. Thus, we can move on to the next row in the matrix. This takes us to
      coordinates [1, 4], where 35 is located. 35 is less than 41, so 41 cannot
      exist in this row either. We keep moving down to [2, 4]. Again, 36 is less
      than 41, so it can’t exist in this row. Moving down one more time to [3,
      4], we land on 45. Since 45 is greater than 41, it <em>can</em> exist in
      this row.
    </p>
    <p>
      Since 45 is greater than 41, we move leftward to [3, 3]. 44 is greater
      than 41, so we continue moving leftward, where we get to [3, 2] and see
      that we need to move leftward again. Finally, at [3, 1], we find 41.
    </p>
    <p>
      So starting in the northeast corner worked because it gave us more
      information as to which direction we could be moving as we searched
      through the matrix. This same idea works just as well if we start in the
      southwest corner, but it would not work if we started in the southeast
      corner for the same reasons it didn’t work when we tried starting in the
      northwest corner. We need to start at the large end of one of the
      dimensions and the small end of the other. It doesn’t work when we start
      at the small end of both dimensions or the large end of both dimensions.
    </p>
    <p>
      With that being said, does this strategy work when we try searching for an
      element that isn’t in the matrix? Let’s see what happens when we try
      searching for 1016 in the matrix. Starting at the northeast corner again,
      we’d see that 999 is less than 1016, so we’d move one row down to [1, 6].
      From there, we’d move down again to [2, 6], then down again to [3, 6].
      We’d start moving leftward from there until we hit [3, 4], where we’d
      noticed that we’d have skipped over 1016 if it existed in the matrix.
      Therefore, 1016 can’t exist in the matrix and we’d return [-1, -1].
    </p>
    <h2 id="evaluating-this-strategy">Evaluating this Strategy</h2>
    <p>
      Let’s the evaluate the time complexity for this algorithm. In the worst
      case, the element we’re looking for would be located in the opposite
      corner as the one we started at. In that case, how many elements would we
      need to check? In that case, we’d have to traverse both the width and the
      height of the entire matrix to get to the opposite corner. So the total
      number of elements we’d end up inspecting in that situation is equal to
      the number of columns plus the number of rows. Thus, the runtime of this
      algorithm will be O(n + m) where n is the number of rows and m is the
      number of columns. This is certainly a much better runtime than O(n * m).
      Can we do even better? Probably not, since doing any better than this
      would entail not checking every row and column at least once in the worst
      case, and we don’t have enough information to be able to make that
      assumption.
    </p>
    <p>
      For the space complexity of this algorithm, we don’t need to allocate
      memory for any data structures or anything like that. All we need to keep
      track of is the current coordinates of where we are in the matrix as we’re
      traversing it, so the space complexity of this algorithm will be O(1).
    </p>
    <h2 id="implementing-the-strategy">Implementing the Strategy</h2>
    <p>
      Now that we’ve sketched out the idea and determined that it’s the best we
      can do, let’s put it down in code:
    </p>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode python"
      ><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> search_in_sorted_matrix(matrix, target):</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co"># initialize variables to keep track of where we are in the matrix</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="co"># we want to start in the northeast (or southwest) corner</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="co"># which has the coordinates [0, len(matrix[0])-1]</span></a>
<a class="sourceLine" id="cb3-5" title="5">    row <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb3-6" title="6">    col <span class="op">=</span> <span class="bu">len</span>(matrix[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="co"># we&#39;ll traverse so long as the row index &lt; len(matrix) and the</span></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="co"># column index &gt;= 0</span></a>
<a class="sourceLine" id="cb3-9" title="9">    <span class="cf">while</span> row <span class="op">&lt;</span> <span class="bu">len</span>(matrix) <span class="kw">and</span> col <span class="op">&gt;=</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb3-10" title="10">        <span class="co"># check if the value at these coordinates is &gt; target</span></a>
<a class="sourceLine" id="cb3-11" title="11">        <span class="cf">if</span> matrix[row][col] <span class="op">&gt;</span> target:</a>
<a class="sourceLine" id="cb3-12" title="12">            <span class="co"># if it is, shift one column to the left</span></a>
<a class="sourceLine" id="cb3-13" title="13">            col <span class="op">-=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="co"># check if the value at these coordinates is &lt; target</span></a>
<a class="sourceLine" id="cb3-15" title="15">        <span class="cf">elif</span> matrix[row][col] <span class="op">&lt;</span> target:</a>
<a class="sourceLine" id="cb3-16" title="16">            <span class="co"># if it is, shift down one row</span></a>
<a class="sourceLine" id="cb3-17" title="17">            row <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb3-18" title="18">        <span class="co"># otherwise, the value at these coordinates is == target</span></a>
<a class="sourceLine" id="cb3-19" title="19">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb3-20" title="20">            <span class="co"># we&#39;ve found the element, return its coordinates</span></a>
<a class="sourceLine" id="cb3-21" title="21">            <span class="cf">return</span> (row, col)</a>
<a class="sourceLine" id="cb3-22" title="22">    <span class="co"># we&#39;ve traversed the entire matrix and didn&#39;t find the matching element</span></a>
<a class="sourceLine" id="cb3-23" title="23">    <span class="cf">return</span> (<span class="op">-</span><span class="dv">1</span>, <span class="dv">-1</span>)</a></code></pre>
    </div>
  </body>
</html>
