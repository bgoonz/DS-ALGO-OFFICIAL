<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>053. Maximum Subarray</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<h2 id="maximum-subarray"><a href="https://leetcode.com/problems/maximum-subarray/description/">53. Maximum Subarray</a></h2>
<h3 id="problem">Problem:</h3>
<p>Given an integer array <code>nums</code>, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.</p>
<p><strong>Example:</strong></p>
<pre><code>Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.</code></pre>
<p><strong>Follow up:</strong></p>
<p>If you have figured out the O(<em>n</em>) solution, try coding another solution using the divide and conquer approach, which is more subtle.</p>
<h3 id="solution">Solution:</h3>
<p>DP.</p>
<p>Define <code>f(i)</code> to be the largest sum of a contiguous subarray that ends with <code>nums[i]</code>.</p>
<p>If <code>f(i-1)</code> is negative, then <code>nums[i]</code> must be greater than <code>f(i-1) + nums[i]</code>.</p>
<pre><code>f(0) = nums[0]
f(i) = max( f(i-1), 0 ) + nums[i]</code></pre>
<p>Then return the largest one.</p>
<pre><code>/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  const len = nums.length
  if (len &lt;= 0) { return 0 }
  const dp = [nums[0]]
  for (let i = 1; i &lt; len; i++) {
    dp[i] = Math.max(dp[i-1], 0) + nums[i]
  }
  return Math.max(...dp)
};</code></pre>
<p>We can also compress the dp array:</p>
<pre><code>/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {
  let dp = nums[0]
  let max = dp || 0
  for (let i = 1; i &lt; nums.length; i++) {
    max = Math.max(max, dp = Math.max(dp, 0) + nums[i])
  }
  return max
};</code></pre>
<p><em>Template generated via <a href="https://github.com/crimx/crx-leetmark">Leetmark</a>.</em></p>
</body>
</html>
