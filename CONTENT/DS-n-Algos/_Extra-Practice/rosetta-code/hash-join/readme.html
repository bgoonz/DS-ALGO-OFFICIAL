<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>readme</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="hash-join">Hash join</h1>
    <p>
      <a
        href="https://www.freecodecamp.org/learn/coding-interview-prep/rosetta-code/hash-join"
        >FCC link</a
      >
    </p>
    <p>
      An
      <a
        href="https://en.wikipedia.org/wiki/Join_(SQL)#Inner_join"
        title="wp: Join_(SQL)#Inner_join"
        >inner join</a
      >
      is an operation that combines two data tables into one table, based on
      matching column values. The simplest way of implementing this operation is
      the
      <a
        href="https://en.wikipedia.org/wiki/Nested%20loop%20join"
        title="wp: Nested loop join"
        >nested loop join</a
      >
      algorithm, but a more scalable alternative is the
      <a href="https://en.wikipedia.org/wiki/hash%20join" title="wp: hash join"
        >hash join</a
      >
      algorithm.
    </p>
    <p>The “hash join” algorithm consists of two steps:</p>
    <ol type="1">
      <li>
        <strong>Hash phase:</strong> Create a
        <a href="https://en.wikipedia.org/wiki/Multimap" title="wp: Multimap"
          >multimap</a
        >
        from one of the two tables, mapping from each join column value to all
        the rows that contain it.
      </li>
    </ol>
    <ul>
      <li>
        The multimap must support hash-based lookup which scales better than a
        simple linear search, because that’s the whole point of this algorithm.
      </li>
      <li>
        Ideally we should create the multimap for the smaller table, thus
        minimizing its creation time and memory size.
      </li>
    </ul>
    <ol start="3" type="1">
      <li>
        <strong>Join phase:</strong> Scan the other table, and find matching
        rows by looking in the multimap created before.
      </li>
    </ol>
    <p>In pseudo-code, the algorithm could be expressed as follows:</p>
    <p>
      <strong>let</strong> <em>A</em> = the first input table (or ideally, the
      larger one) <strong>let</strong> <em>B</em> = the second input table (or
      ideally, the smaller one) <strong>let</strong> <em>jA</em> = the join
      column ID of table <em>A</em> <strong>let</strong> <em>jB</em> = the join
      column ID of table <em>B</em> <strong>let</strong> <em>MB</em> = a
      multimap for mapping from single values to multiple rows of table
      <em>B</em> (starts out empty) <strong>let</strong> <em>C</em> = the output
      table (starts out empty) <strong>for each</strong> row <em>b</em> in table
      <em>B</em>: <strong>place</strong> <em>b</em> in multimap
      <em>MB</em> under key <em>b(jB)</em> <strong>for each</strong> row
      <em>a</em> in table <em>A</em>: <strong>for each</strong> row
      <em>b</em> in multimap <em>MB</em> under key <em>a(jA)</em>:
      <strong>let</strong> <em>c</em> = the concatenation of row <em>a</em> and
      row <em>b</em> <strong>place</strong> row <em>c</em> in table <em>C</em>
    </p>
  </body>
</html>
