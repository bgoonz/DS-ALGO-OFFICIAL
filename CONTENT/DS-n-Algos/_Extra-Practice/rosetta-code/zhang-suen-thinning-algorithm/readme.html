<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>readme</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="zhang-suen-thinning-algorithm">Zhang-Suen thinning algorithm</h1>
    <p>
      <a
        href="https://www.freecodecamp.org/learn/coding-interview-prep/rosetta-code/zhang-suen-thinning-algorithm"
        >FCC link</a
      >
    </p>
    <p>
      This is an algorithm used to thin a black and white i.e. one bit per pixel
      images. For example, with an input image of:
    </p>
    <p id="section">############# ##################</p>
    <p id="section-1">################## ######## #######</p>
    <h6 id="section-2"></h6>
    <h6 id="section-3"></h6>
    <p id="section-4">####### ################ ####### #################</p>
    <h6 id="section-5"></h6>
    <h6 id="section-6"></h6>
    <h6 id="section-7"></h6>
    <p id="section-8">####### ################### ######## #######</p>
    <p id="section-9">###### ######## ####### ###### ################</p>
    <p id="section-10">####### ###### #############</p>
    <p>It produces the thinned output:</p>
    <pre><code># ##########                       #######
 ##        #                   ####       #
 #          #                 ##
 #          #                #
 #          #                #
 #          #                #
 ############               #
 #          #               #
 #          #                #
 #          #                #
 #          #                #
 #                            ##
 #                             ############
                   ###                          ###</code></pre>
    <h2 id="algorithm">Algorithm</h2>
    <p>
      Assume black pixels are one and white pixels zero, and that the input
      image is a rectangular N by M array of ones and zeroes. The algorithm
      operates on all black pixels P1 that can have eight neighbours. The
      neighbours are, in order, arranged as:
    </p>
    <table border="3">
      <tbody>
        <tr>
          <td style="text-align: center">P9</td>
          <td style="text-align: center">P2</td>
          <td style="text-align: center">P3</td>
        </tr>
        <tr>
          <td style="text-align: center">P8</td>
          <td style="text-align: center">
            <strong>P1</strong>
          </td>
          <td style="text-align: center">P4</td>
        </tr>
        <tr>
          <td style="text-align: center">P7</td>
          <td style="text-align: center">P6</td>
          <td style="text-align: center">P5</td>
        </tr>
      </tbody>
    </table>
    <p>
      Obviously the boundary pixels of the image cannot have the full eight
      neighbours.
    </p>
    <ul>
      <li>
        Define <span class="math inline"><em>A</em>(<em>P</em>1)</span> = the
        number of transitions from white to black, (0 -&gt; 1) in the sequence
        P2, P3, P4, P5, P6, P7, P8, P9, P2. (Note the extra P2 at the end - it
        is circular).
      </li>
      <li>
        Define <span class="math inline"><em>B</em>(<em>P</em>1)</span> = the
        number of black pixel neighbours of P1. ( = sum(P2 .. P9) )
      </li>
    </ul>
    <p><strong>Step 1:</strong></p>
    <p>
      All pixels are tested and pixels satisfying all the following conditions
      (simultaneously) are just noted at this stage.
    </p>
    <ol type="1">
      <li>The pixel is black and has eight neighbours</li>
      <li>
        <span class="math inline"
          >2 &lt;  = <em>B</em>(<em>P</em>1) &lt;  = 6</span
        >
      </li>
      <li>
        <span class="math inline"><em>A</em>(<em>P</em>1) = 1</span>
      </li>
      <li>At least one of <strong>P2, P4 and P6</strong> is white</li>
      <li>At least one of <strong>P4, P6 and P8</strong> is white</li>
    </ol>
    <p>
      After iterating over the image and collecting all the pixels satisfying
      all step 1 conditions, all these condition satisfying pixels are set to
      white.
    </p>
    <p><strong>Step 2:</strong></p>
    <p>
      All pixels are again tested and pixels satisfying all the following
      conditions are just noted at this stage.
    </p>
    <ol type="1">
      <li>The pixel is black and has eight neighbours</li>
      <li>
        <span class="math inline"
          >2 &lt;  = <em>B</em>(<em>P</em>1) &lt;  = 6</span
        >
      </li>
      <li>
        <span class="math inline"><em>A</em>(<em>P</em>1) = 1</span>
      </li>
      <li>At least one of <strong>P2, P4 and P8</strong> is white</li>
      <li>At least one of <strong>P2, P6 and P8</strong> is white</li>
    </ol>
    <p>
      After iterating over the image and collecting all the pixels satisfying
      all step 2 conditions, all these condition satisfying pixels are again set
      to white.
    </p>
    <p><strong>Iteration:</strong></p>
    <p>
      If any pixels were set in this round of either step 1 or step 2 then all
      steps are repeated until no image pixels are so changed.
    </p>
  </body>
</html>
