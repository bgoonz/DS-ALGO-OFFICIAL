{
  "title": "Zhang-Suen thinning algorithm",
  "htmlDescription": "<section id=\"description\">\n<p>This is an algorithm used to thin a black and white i.e. one bit per pixel images. For example, with an input image of:</p>\n<!-- TODO write fully in markdown>\n<!-- markdownlint-disable -->\n<pre>\n #################                   #############\n ##################               ################\n ###################            ##################\n ########     #######          ###################\n   ######     #######         #######       ######\n   ######     #######        #######\n   #################         #######\n   ################          #######\n   #################         #######\n   ######     #######        #######\n   ######     #######        #######\n   ######     #######         #######       ######\n ########     #######          ###################\n ########     ####### ######    ################## ######\n ########     ####### ######      ################ ######\n ########     ####### ######         ############# ######\n</pre>\n<p>It produces the thinned output:</p>\n<pre>\n\n    # ##########                       #######\n     ##        #                   ####       #\n     #          #                 ##\n     #          #                #\n     #          #                #\n     #          #                #\n     ############               #\n     #          #               #\n     #          #                #\n     #          #                #\n     #          #                #\n     #                            ##\n     #                             ############\n                       ###                          ###\n\n</pre>\n<h2>Algorithm</h2>\n<p>Assume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes. The algorithm operates on all black pixels P1 that can have eight neighbours. The neighbours are, in order, arranged as:</p>\n<table border=\"3\">\n  <tr><td style=\"text-align: center;\">P9</td><td style=\"text-align: center;\">P2</td><td style=\"text-align: center;\">P3</td></tr>\n  <tr><td style=\"text-align: center;\">P8</td><td style=\"text-align: center;\"><strong>P1</strong></td><td style=\"text-align: center;\">P4</td></tr>\n  <tr><td style=\"text-align: center;\">P7</td><td style=\"text-align: center;\">P6</td><td style=\"text-align: center;\">P5</td></tr>\n</table>\n<p>Obviously the boundary pixels of the image cannot have the full eight neighbours.</p>\n<ul>\n  <li>Define $A(P1)$ = the number of transitions from white to black, (0 -> 1) in the sequence P2, P3, P4, P5, P6, P7, P8, P9, P2. (Note the extra P2 at the end - it is circular).</li>\n  <li>Define $B(P1)$ = the number of black pixel neighbours of P1. ( = sum(P2 .. P9) )</li>\n</ul>\n<p><strong>Step 1:</strong></p>\n<p>All pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.</p>\n  <ol>\n    <li>The pixel is black and has eight neighbours</li>\n    <li>$2 <= B(P1) <= 6$</li>\n    <li>$A(P1) = 1$</li>\n    <li>At least one of <strong>P2, P4 and P6</strong> is white</li>\n    <li>At least one of <strong>P4, P6 and P8</strong> is white</li>\n  </ol>\n<p>After iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.</p>\n<p><strong>Step 2:</strong></p>\n<p>All pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.</p>\n  <ol>\n    <li>The pixel is black and has eight neighbours</li>\n    <li>$2 <= B(P1) <= 6$</li>\n    <li>$A(P1) = 1$</li>\n    <li>At least one of <strong>P2, P4 and P8</strong> is white</li>\n    <li>At least one of <strong>P2, P6 and P8</strong> is white</li>\n  </ol>\n<p>After iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.</p>\n<p><strong>Iteration:</strong></p>\n<p>If any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.</p>\n</section>",
  "boilerplate": "const testImage = [\n  '                                                          ',\n  ' #################                   #############        ',\n  ' ##################               ################        ',\n  ' ###################            ##################        ',\n  ' ########     #######          ###################        ',\n  '   ######     #######         #######       ######        ',\n  '   ######     #######        #######                      ',\n  '   #################         #######                      ',\n  '   ################          #######                      ',\n  '   #################         #######                      ',\n  '   ######     #######        #######                      ',\n  '   ######     #######        #######                      ',\n  '   ######     #######         #######       ######        ',\n  ' ########     #######          ###################        ',\n  ' ########     ####### ######    ################## ###### ',\n  ' ########     ####### ######      ################ ###### ',\n  ' ########     ####### ######         ############# ###### ',\n  '                                                          '];\n\nfunction thinImage(image) {\n\n}",
  "url": "https://www.freecodecamp.org/learn/coding-interview-prep/rosetta-code/zhang-suen-thinning-algorithm"
}