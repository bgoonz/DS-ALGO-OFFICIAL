<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>readme</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h1 id="insert-an-element-into-a-max-heap">
      Insert an Element into a Max Heap
    </h1>
    <p>
      <a
        href="https://www.freecodecamp.org/learn/coding-interview-prep/data-structures/insert-an-element-into-a-max-heap"
        >FCC link</a
      >
    </p>
    <p>
      Now we will move on to another tree data structure, the binary heap. A
      binary heap is a partially ordered binary tree which satisfies the heap
      property. The heap property specifies a relationship between parent and
      child nodes. You may have a max heap, in which all parent nodes are
      greater than or equal to their child nodes, or a min heap, in which the
      reverse is true. Binary heaps are also complete binary trees. This means
      that all levels of the tree are fully filled and if the last level is
      partially filled it is filled from left to right.
    </p>
    <p>
      While binary heaps may be implemented as tree structures with nodes that
      contain left and right references, the partial ordering according to the
      heap property allows us to represent the heap with an array. The
      parent-children relationship is what we’re interested in and with simple
      arithmetic we can compute the children of any parent and the parent of any
      child node.
    </p>
    <p>
      For instance, consider this array representation of a binary min heap:
    </p>
    <div class="sourceCode" id="cb1">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1">[<span class="dv">6</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">63</span><span class="op">,</span> <span class="dv">48</span><span class="op">,</span> <span class="dv">42</span><span class="op">,</span> <span class="dv">76</span>]<span class="op">;</span></a></code></pre>
    </div>
    <p>
      The root node is the first element, <code>6</code>. Its children are
      <code>22</code> and <code>30</code>. If we look at the relationship
      between the array indices of these values, for index <code>i</code> the
      children are <code>2 * i + 1</code> and <code>2 * i + 2</code>. Similarly,
      the element at index <code>0</code> is the parent of these two children at
      indices <code>1</code> and <code>2</code>. More generally, we can find the
      parent of a node at any index with the following:
      <code>Math.floor((i - 1) / 2)</code>. These patterns will hold true as the
      binary tree grows to any size. Finally, we can make a slight adjustment to
      make this arithmetic even easier by skipping the first element in the
      array. Doing this creates the following relationship for any element at a
      given index <code>i</code>:
    </p>
    <p>Example array representation:</p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1">[<span class="kw">null</span><span class="op">,</span> <span class="dv">6</span><span class="op">,</span> <span class="dv">22</span><span class="op">,</span> <span class="dv">30</span><span class="op">,</span> <span class="dv">37</span><span class="op">,</span> <span class="dv">63</span><span class="op">,</span> <span class="dv">48</span><span class="op">,</span> <span class="dv">42</span><span class="op">,</span> <span class="dv">76</span>]<span class="op">;</span></a></code></pre>
    </div>
    <p>An element’s left child: <code>i * 2</code></p>
    <p>An element’s right child: <code>i * 2 + 1</code></p>
    <p>An element’s parent: <code>Math.floor(i / 2)</code></p>
    <p>
      Once you wrap your head around the math, using an array representation is
      very useful because node locations can be quickly determined with this
      arithmetic and memory usage is diminished because you don’t need to
      maintain references to child nodes.
    </p>
  </body>
</html>
