<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>readme</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1 id="check-if-an-element-is-present-in-a-binary-search-tree">
      Check if an Element is Present in a Binary Search Tree
    </h1>
    <p>
      <a
        href="https://www.freecodecamp.org/learn/coding-interview-prep/data-structures/check-if-an-element-is-present-in-a-binary-search-tree"
        >FCC link</a
      >
    </p>
    <p>
      Now that we have a general sense of what a binary search tree is let’s
      talk about it in a little more detail. Binary search trees provide
      logarithmic time for the common operations of lookup, insertion, and
      deletion in the average case, and linear time in the worst case. Why is
      this? Each of those basic operations requires us to find an item in the
      tree (or in the case of insertion to find where it should go) and because
      of the tree structure at each parent node we are branching left or right
      and effectively excluding half the size of the remaining tree. This makes
      the search proportional to the logarithm of the number of nodes in the
      tree, which creates logarithmic time for these operations in the average
      case. Ok, but what about the worst case? Well, consider constructing a
      tree from the following values, adding them left to right:
      <code>10</code>, <code>12</code>, <code>17</code>, <code>25</code>.
      Following our rules for a binary search tree, we will add
      <code>12</code> to the right of <code>10</code>, <code>17</code> to the
      right of this, and <code>25</code> to the right of this. Now our tree
      resembles a linked list and traversing it to find <code>25</code> would
      require us to traverse all the items in linear fashion. Hence, linear time
      in the worst case. The problem here is that the tree is unbalanced. We’ll
      look a little more into what this means in the following challenges.
    </p>
  </body>
</html>
