<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>057. Insert Interval</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h2 id="insert-interval">
      <a href="https://leetcode.com/problems/insert-interval/description/"
        >57. Insert Interval</a
      >
    </h2>
    <h3 id="problem">Problem:</h3>
    <p>
      Given a set of <em>non-overlapping</em> intervals, insert a new interval
      into the intervals (merge if necessary).
    </p>
    <p>
      You may assume that the intervals were initially sorted according to their
      start times.
    </p>
    <p><strong>Example 1:</strong></p>
    <pre><code>Input: intervals = [[1,3],[6,9]], newInterval = [2,5]
Output: [[1,5],[6,9]]</code></pre>
    <p><strong>Example 2:</strong></p>
    <pre><code>Input: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]
Output: [[1,2],[3,10],[12,16]]
Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].</code></pre>
    <h3 id="solution">Solution:</h3>
    <p>
      The logic of the solution is pretty straight forward. Just need to
      carefully think through all the edge cases. It is better to choose
      readability over performance.
    </p>
    <pre><code>/**
 * Definition for an interval.
 * function Interval(start, end) {
 *     this.start = start;
 *     this.end = end;
 * }
 */
/**
 * @param {Interval[]} intervals
 * @param {Interval} newInterval
 * @return {Interval[]}
 */
var insert = function(intervals, newInterval) {
  const result = []
  const p = new Interval(newInterval.start, newInterval.end)
  for (var i = 0; i &lt; intervals.length; i++) {
    const { start, end } = intervals[i]
    if (start &gt; p.end) {
      break
    }

    if (end &lt; p.start) {
      result.push(intervals[i])
      continue
    }

    if (start &lt; p.start) {
      p.start = start
    }

    if (end &gt; p.end) {
      p.end = end
    }
  }
  return [...result, p, ...intervals.slice(i)]
};</code></pre>
    <p>
      <em
        >Template generated via
        <a href="https://github.com/crimx/crx-leetmark">Leetmark</a>.</em
      >
    </p>
  </body>
</html>
