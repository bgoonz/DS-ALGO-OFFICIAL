<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>final</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Comment let */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <h2
      id="given-two-binary-trees-write-a-function-to-check-if-they-are-the-same-or-not."
    >
      Given two binary trees, write a function to check if they are the same or
      not.
    </h2>
    <pre><code>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.

Example 1:

Input:     1         1
          / \       / \
         2   3     2   3

        [1,2,3],   [1,2,3]

Output: true</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject">class TreeNode(object):</h3>
    <h3 id="def-initself-x">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x">self.val = x</h3>
    <h3 id="self.left-none">self.left = None</h3>
    <h3 id="self.right-none">self.right = None</h3>
    <p>
      class Solution(object): def isSameTree(self, p, q): :type p: TreeNode
      :type q: TreeNode :rtype: bool if not p and not q: return True
    </p>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">        stack <span class="op">=</span> [(p, q)]</a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3">        <span class="cf">while</span> stack:</a>
<a class="sourceLine" id="cb2-4" title="4">            node1, node2 <span class="op">=</span> stack.pop()</a>
<a class="sourceLine" id="cb2-5" title="5">            <span class="cf">if</span> node1 <span class="kw">and</span> node2 <span class="kw">and</span> node1.val <span class="op">==</span> node2.val:</a>
<a class="sourceLine" id="cb2-6" title="6">                stack.append((node1.left, node2.left))</a>
<a class="sourceLine" id="cb2-7" title="7">                stack.append((node1.right, node2.right))</a>
<a class="sourceLine" id="cb2-8" title="8">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb2-9" title="9">                <span class="cf">if</span> <span class="kw">not</span> node1 <span class="op">==</span> node2:</a>
<a class="sourceLine" id="cb2-10" title="10">                    <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb2-11" title="11"></a>
<a class="sourceLine" id="cb2-12" title="12">        <span class="cf">return</span> <span class="va">True</span></a></code></pre>
    </div>
    <h2
      id="given-a-binary-tree-check-whether-it-is-a-mirror-of-itself-ie-symmetric-around-its-center."
    >
      Given a binary tree, check whether it is a mirror of itself (ie, symmetric
      around its center).
    </h2>
    <pre><code>For example, this binary tree [1,2,2,3,4,4,3] is symmetric:

    1
   / \
  2   2
 / \ / \
3  4 4  3

But the following [1,2,2,null,3,null,3] is not:

    1
   / \
  2   2
   \   \
   3    3</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-1">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-1">class TreeNode(object):</h3>
    <h3 id="def-initself-x-1">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-1">self.val = x</h3>
    <h3 id="self.left-none-1">self.left = None</h3>
    <h3 id="self.right-none-1">self.right = None</h3>
    <div class="sourceCode" id="cb4">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> isSymmetric(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: <span class="bu">bool</span>  <span class="cf">if</span> <span class="kw">not</span> root: <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3">        <span class="kw">def</span> dfs(left, right):</a>
<a class="sourceLine" id="cb4-4" title="4">            <span class="cf">if</span> <span class="kw">not</span> left <span class="kw">and</span> <span class="kw">not</span> right:</a>
<a class="sourceLine" id="cb4-5" title="5">                <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb4-6" title="6"></a>
<a class="sourceLine" id="cb4-7" title="7">            <span class="cf">if</span> <span class="kw">not</span> left <span class="kw">or</span> <span class="kw">not</span> right:</a>
<a class="sourceLine" id="cb4-8" title="8">                <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb4-9" title="9">            <span class="cf">return</span> (</a>
<a class="sourceLine" id="cb4-10" title="10">                (left.val <span class="op">==</span> right.val)</a>
<a class="sourceLine" id="cb4-11" title="11">                <span class="kw">and</span> dfs(left.left, right.right)</a>
<a class="sourceLine" id="cb4-12" title="12">                <span class="kw">and</span> dfs(left.right, right.left)</a>
<a class="sourceLine" id="cb4-13" title="13">            )</a>
<a class="sourceLine" id="cb4-14" title="14"></a>
<a class="sourceLine" id="cb4-15" title="15">        <span class="cf">return</span> dfs(root, root)</a></code></pre>
    </div>
    <h2
      id="given-a-binary-tree-return-the-level-order-traversal-of-its-nodes-values.-ie-from-left-to-right-level-by-level."
    >
      Given a binary tree, return the level order traversal of its nodes’
      values. (ie, from left to right, level by level).
    </h2>
    <pre><code>For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its level order traversal as:

[
  [3],
  [9,20],
  [15,7]
]</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-2">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-2">class TreeNode(object):</h3>
    <h3 id="def-initself-x-2">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-2">self.val = x</h3>
    <h3 id="self.left-none-2">self.left = None</h3>
    <h3 id="self.right-none-2">self.right = None</h3>
    <p>
      class Solution(object): def levelOrder(self, root): :type root: TreeNode
      :rtype: List[List[int]]
    </p>
    <div class="sourceCode" id="cb6">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb6-1" title="1">        <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb6-2" title="2">            <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4">        queue <span class="op">=</span> [(root, <span class="dv">0</span>)]</a>
<a class="sourceLine" id="cb6-5" title="5">        levelMap <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="cf">while</span> queue:</a>
<a class="sourceLine" id="cb6-8" title="8">            node, level <span class="op">=</span> queue.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb6-9" title="9">            <span class="cf">if</span> node.left:</a>
<a class="sourceLine" id="cb6-10" title="10">                queue.append((node.left, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb6-11" title="11">            <span class="cf">if</span> node.right:</a>
<a class="sourceLine" id="cb6-12" title="12">                queue.append((node.right, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb6-13" title="13"></a>
<a class="sourceLine" id="cb6-14" title="14">            <span class="cf">if</span> level <span class="kw">in</span> levelMap:</a>
<a class="sourceLine" id="cb6-15" title="15">                levelMap[level].append(node.val)</a>
<a class="sourceLine" id="cb6-16" title="16">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb6-17" title="17">                levelMap[level] <span class="op">=</span> [node.val]</a>
<a class="sourceLine" id="cb6-18" title="18"></a>
<a class="sourceLine" id="cb6-19" title="19">        result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb6-20" title="20">        <span class="cf">for</span> key, value <span class="kw">in</span> levelMap.iteritems():</a>
<a class="sourceLine" id="cb6-21" title="21">            result.append(value)</a>
<a class="sourceLine" id="cb6-22" title="22">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <h2
      id="given-a-binary-tree-return-the-zigzag-level-order-traversal-of-its-nodes-values.-ie-from-left-to-right-then-right-to-left-for-the-next-level-and-alternate-between."
    >
      Given a binary tree, return the zigzag level order traversal of its nodes’
      values. (ie, from left to right, then right to left for the next level and
      alternate between).
    </h2>
    <pre><code>For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its zigzag level order traversal as:

[
  [3],
  [20,9],
  [15,7]
]</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-3">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-3">class TreeNode(object):</h3>
    <h3 id="def-initself-x-3">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-3">self.val = x</h3>
    <h3 id="self.left-none-3">self.left = None</h3>
    <h3 id="self.right-none-3">self.right = None</h3>
    <p>
      class Solution(object): def zigzagLevelOrder(self, root): :type root:
      TreeNode :rtype: List[List[int]]
    </p>
    <div class="sourceCode" id="cb8">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1">        <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb8-2" title="2">            <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb8-3" title="3"></a>
<a class="sourceLine" id="cb8-4" title="4">        queue <span class="op">=</span> [(root, <span class="dv">0</span>)]</a>
<a class="sourceLine" id="cb8-5" title="5">        levelMap <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7">        <span class="cf">while</span> queue:</a>
<a class="sourceLine" id="cb8-8" title="8">            node, level <span class="op">=</span> queue.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb8-9" title="9">            <span class="cf">if</span> node.left:</a>
<a class="sourceLine" id="cb8-10" title="10">                queue.append((node.left, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb8-11" title="11">            <span class="cf">if</span> node.right:</a>
<a class="sourceLine" id="cb8-12" title="12">                queue.append((node.right, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb8-13" title="13"></a>
<a class="sourceLine" id="cb8-14" title="14">            <span class="cf">if</span> level <span class="kw">in</span> levelMap:</a>
<a class="sourceLine" id="cb8-15" title="15">                levelMap[level].append(node.val)</a>
<a class="sourceLine" id="cb8-16" title="16">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb8-17" title="17">                levelMap[level] <span class="op">=</span> [node.val]</a>
<a class="sourceLine" id="cb8-18" title="18"></a>
<a class="sourceLine" id="cb8-19" title="19">        result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb8-20" title="20">        spiral <span class="op">=</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb8-21" title="21">        <span class="cf">for</span> key, value <span class="kw">in</span> levelMap.iteritems():</a>
<a class="sourceLine" id="cb8-22" title="22">            <span class="cf">if</span> spiral:</a>
<a class="sourceLine" id="cb8-23" title="23">                value <span class="op">=</span> value[::<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb8-24" title="24">            result.append(value)</a>
<a class="sourceLine" id="cb8-25" title="25">            spiral <span class="op">=</span> <span class="kw">not</span> spiral</a>
<a class="sourceLine" id="cb8-26" title="26">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <h2
      id="given-a-non-empty-string-s-and-a-dictionary-worddict-containing-a-list-of-non-empty-words-determine-if-s-can-be-segmented-into-a-space-separated-sequence-of-one-or-more-dictionary-words."
    >
      Given a non-empty string s and a dictionary wordDict containing a list of
      non-empty words, determine if s can be segmented into a space-separated
      sequence of one or more dictionary words.
    </h2>
    <pre><code>Note:

The same word in the dictionary may be reused multiple times in the segmentation.
You may assume the dictionary does not contain duplicate words.
Example 1:

Input: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]
Output: true
Explanation: Return true because &quot;leetcode&quot; can be segmented as &quot;leet code&quot;.</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-4">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-4">class TreeNode(object):</h3>
    <h3 id="def-initself-x-4">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-4">self.val = x</h3>
    <h3 id="self.left-none-4">self.left = None</h3>
    <h3 id="self.right-none-4">self.right = None</h3>
    <p>
      class Solution(object): def buildTree(self, preorder, inorder): :type
      preorder: List[int] :type inorder: List[int] :rtype: TreeNode self.index =
      0
    </p>
    <div class="sourceCode" id="cb10">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1">        <span class="kw">def</span> recursive(preorder, inorder, start, end):</a>
<a class="sourceLine" id="cb10-2" title="2">            <span class="cf">if</span> start <span class="op">&gt;</span> end:</a>
<a class="sourceLine" id="cb10-3" title="3">                <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5">            node <span class="op">=</span> TreeNode(preorder[<span class="va">self</span>.index])</a>
<a class="sourceLine" id="cb10-6" title="6">            <span class="va">self</span>.index <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb10-7" title="7">            <span class="cf">if</span> start <span class="op">==</span> end:</a>
<a class="sourceLine" id="cb10-8" title="8">                <span class="cf">return</span> node</a>
<a class="sourceLine" id="cb10-9" title="9"></a>
<a class="sourceLine" id="cb10-10" title="10">            search_index <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb10-11" title="11">            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb10-12" title="12">                <span class="cf">if</span> inorder[i] <span class="op">==</span> node.val:</a>
<a class="sourceLine" id="cb10-13" title="13">                    search_index <span class="op">=</span> i</a>
<a class="sourceLine" id="cb10-14" title="14">                    <span class="cf">break</span></a>
<a class="sourceLine" id="cb10-15" title="15"></a>
<a class="sourceLine" id="cb10-16" title="16">            node.left <span class="op">=</span> recursive(preorder, inorder, start, search_index <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb10-17" title="17">            node.right <span class="op">=</span> recursive(preorder, inorder, search_index <span class="op">+</span> <span class="dv">1</span>, end)</a>
<a class="sourceLine" id="cb10-18" title="18">            <span class="cf">return</span> node</a>
<a class="sourceLine" id="cb10-19" title="19"></a>
<a class="sourceLine" id="cb10-20" title="20">        <span class="cf">return</span> recursive(preorder, inorder, <span class="dv">0</span>, <span class="bu">len</span>(inorder) <span class="op">-</span> <span class="dv">1</span>)</a></code></pre>
    </div>
    <h2
      id="given-inorder-and-postorder-traversal-of-a-tree-construct-the-binary-tree."
    >
      Given inorder and postorder traversal of a tree, construct the binary
      tree.
    </h2>
    <pre><code>Note:
You may assume that duplicates do not exist in the tree.

For example, given

inorder = [9,3,15,20,7]
postorder = [9,15,7,20,3]
Return the following binary tree:

    3
   / \
  9  20
    /  \
   15   7</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-5">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-5">class TreeNode(object):</h3>
    <h3 id="def-initself-x-5">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-5">self.val = x</h3>
    <h3 id="self.left-none-5">self.left = None</h3>
    <h3 id="self.right-none-5">self.right = None</h3>
    <p>
      class Solution(object): def buildTree(self, inorder, postorder): :type
      inorder: List[int] :type postorder: List[int] :rtype: TreeNode self.index
      = len(inorder) - 1
    </p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1">        <span class="kw">def</span> recursive(postorder, inorder, start, end):</a>
<a class="sourceLine" id="cb12-2" title="2">            <span class="cf">if</span> start <span class="op">&gt;</span> end:</a>
<a class="sourceLine" id="cb12-3" title="3">                <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb12-4" title="4"></a>
<a class="sourceLine" id="cb12-5" title="5">            node <span class="op">=</span> TreeNode(postorder[<span class="va">self</span>.index])</a>
<a class="sourceLine" id="cb12-6" title="6">            <span class="va">self</span>.index <span class="op">-=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-7" title="7">            <span class="cf">if</span> start <span class="op">==</span> end:</a>
<a class="sourceLine" id="cb12-8" title="8">                <span class="cf">return</span> node</a>
<a class="sourceLine" id="cb12-9" title="9"></a>
<a class="sourceLine" id="cb12-10" title="10">            search_index <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb12-11" title="11">            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb12-12" title="12">                <span class="cf">if</span> inorder[i] <span class="op">==</span> node.val:</a>
<a class="sourceLine" id="cb12-13" title="13">                    search_index <span class="op">=</span> i</a>
<a class="sourceLine" id="cb12-14" title="14">                    <span class="cf">break</span></a>
<a class="sourceLine" id="cb12-15" title="15">            node.right <span class="op">=</span> recursive(postorder, inorder, search_index <span class="op">+</span> <span class="dv">1</span>, end)</a>
<a class="sourceLine" id="cb12-16" title="16">            node.left <span class="op">=</span> recursive(postorder, inorder, start, search_index <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb12-17" title="17">            <span class="cf">return</span> node</a>
<a class="sourceLine" id="cb12-18" title="18"></a>
<a class="sourceLine" id="cb12-19" title="19">        <span class="cf">return</span> recursive(postorder, inorder, <span class="dv">0</span>, <span class="bu">len</span>(inorder) <span class="op">-</span> <span class="dv">1</span>)</a></code></pre>
    </div>
    <h2
      id="given-a-binary-tree-return-the-bottom-up-level-order-traversal-of-its-nodes-values.-ie-from-left-to-right-level-by-level-from-leaf-to-root."
    >
      Given a binary tree, return the bottom-up level order traversal of its
      nodes’ values. (ie, from left to right, level by level from leaf to root).
    </h2>
    <pre><code>For example:
Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its bottom-up level order traversal as:

[
  [15,7],
  [9,20],
  [3]
]</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-6">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-6">class TreeNode(object):</h3>
    <h3 id="def-initself-x-6">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-6">self.val = x</h3>
    <h3 id="self.left-none-6">self.left = None</h3>
    <h3 id="self.right-none-6">self.right = None</h3>
    <p>
      class Solution(object): def levelOrderBottom(self, root): :type root:
      TreeNode :rtype: List[List[int]]
    </p>
    <div class="sourceCode" id="cb14">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb14-1" title="1">        <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb14-2" title="2">            <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb14-3" title="3"></a>
<a class="sourceLine" id="cb14-4" title="4">        queue <span class="op">=</span> [(root, <span class="dv">0</span>)]</a>
<a class="sourceLine" id="cb14-5" title="5">        levelMap <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">        <span class="cf">while</span> queue:</a>
<a class="sourceLine" id="cb14-8" title="8">            node, level <span class="op">=</span> queue.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb14-9" title="9">            <span class="cf">if</span> node.left:</a>
<a class="sourceLine" id="cb14-10" title="10">                queue.append((node.left, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb14-11" title="11">            <span class="cf">if</span> node.right:</a>
<a class="sourceLine" id="cb14-12" title="12">                queue.append((node.right, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb14-13" title="13"></a>
<a class="sourceLine" id="cb14-14" title="14">            <span class="cf">if</span> level <span class="kw">in</span> levelMap:</a>
<a class="sourceLine" id="cb14-15" title="15">                levelMap[level].append(node.val)</a>
<a class="sourceLine" id="cb14-16" title="16">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb14-17" title="17">                levelMap[level] <span class="op">=</span> [node.val]</a>
<a class="sourceLine" id="cb14-18" title="18"></a>
<a class="sourceLine" id="cb14-19" title="19">        result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb14-20" title="20">        <span class="cf">for</span> key, value <span class="kw">in</span> levelMap.iteritems():</a>
<a class="sourceLine" id="cb14-21" title="21">            result.append(value)</a>
<a class="sourceLine" id="cb14-22" title="22">        <span class="cf">return</span> result[::<span class="op">-</span><span class="dv">1</span>]</a></code></pre>
    </div>
    <h2
      id="given-an-array-where-elements-are-sorted-in-ascending-order-convert-it-to-a-height-balanced-bst."
    >
      Given an array where elements are sorted in ascending order, convert it to
      a height balanced BST.
    </h2>
    <pre><code>For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

Example:

Given the sorted array: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-7">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-7">class TreeNode(object):</h3>
    <h3 id="def-initself-x-7">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-7">self.val = x</h3>
    <h3 id="self.left-none-7">self.left = None</h3>
    <h3 id="self.right-none-7">self.right = None</h3>
    <p>
      class Solution(object): def sortedArrayToBST(self, nums): :type nums:
      List[int] :rtype: TreeNode
    </p>
    <div class="sourceCode" id="cb16">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb16-1" title="1">        <span class="kw">def</span> constructTree(nums, start, end):</a>
<a class="sourceLine" id="cb16-2" title="2">            <span class="cf">if</span> start <span class="op">&gt;</span> end:</a>
<a class="sourceLine" id="cb16-3" title="3">                <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb16-4" title="4"></a>
<a class="sourceLine" id="cb16-5" title="5">            mid <span class="op">=</span> (start <span class="op">+</span> end) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb16-6" title="6">            node <span class="op">=</span> TreeNode(nums[mid])</a>
<a class="sourceLine" id="cb16-7" title="7"></a>
<a class="sourceLine" id="cb16-8" title="8">            <span class="cf">if</span> start <span class="op">==</span> end:</a>
<a class="sourceLine" id="cb16-9" title="9">                <span class="cf">return</span> node</a>
<a class="sourceLine" id="cb16-10" title="10"></a>
<a class="sourceLine" id="cb16-11" title="11">            node.left <span class="op">=</span> constructTree(nums, start, mid <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-12" title="12">            node.right <span class="op">=</span> constructTree(nums, mid <span class="op">+</span> <span class="dv">1</span>, end)</a>
<a class="sourceLine" id="cb16-13" title="13">            <span class="cf">return</span> node</a>
<a class="sourceLine" id="cb16-14" title="14"></a>
<a class="sourceLine" id="cb16-15" title="15">        <span class="cf">return</span> constructTree(nums, <span class="dv">0</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span>)</a></code></pre>
    </div>
    <h2 id="given-a-binary-tree-find-its-minimum-depth.">
      Given a binary tree, find its minimum depth.
    </h2>
    <pre><code>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.

Note: A leaf is a node with no children.

Example:

Given binary tree [3,9,20,null,null,15,7],

    3
   / \
  9  20
    /  \
   15   7

return its minimum depth = 2.</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-8">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-8">class TreeNode(object):</h3>
    <h3 id="def-initself-x-8">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-8">self.val = x</h3>
    <h3 id="self.left-none-8">self.left = None</h3>
    <h3 id="self.right-none-8">self.right = None</h3>
    <p>
      class Solution(object): def minDepth(self, root): if not root: return 0
      depth = float(“inf”) stack = [(root, 1)]
    </p>
    <div class="sourceCode" id="cb18">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb18-1" title="1">        <span class="cf">while</span> stack:</a>
<a class="sourceLine" id="cb18-2" title="2">            node, level <span class="op">=</span> stack.pop()</a>
<a class="sourceLine" id="cb18-3" title="3">            <span class="cf">if</span> node:</a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5">                <span class="cf">if</span> <span class="kw">not</span> node.left <span class="kw">and</span> <span class="kw">not</span> node.right:</a>
<a class="sourceLine" id="cb18-6" title="6">                    depth <span class="op">=</span> <span class="bu">min</span>(depth, level)</a>
<a class="sourceLine" id="cb18-7" title="7"></a>
<a class="sourceLine" id="cb18-8" title="8">                stack.append((node.left, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb18-9" title="9">                stack.append((node.right, level <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb18-10" title="10"></a>
<a class="sourceLine" id="cb18-11" title="11">        <span class="cf">return</span> depth</a></code></pre>
    </div>
    <h2
      id="given-a-binary-tree-and-a-sum-determine-if-the-tree-has-a-root-to-leaf-path-such-that-adding-up-all-the-values-along-the-path-equals-the-given-sum."
    >
      Given a binary tree and a sum, determine if the tree has a root-to-leaf
      path such that adding up all the values along the path equals the given
      sum.
    </h2>
    <pre><code>Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \      \
7    2      1</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-9">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-9">class TreeNode(object):</h3>
    <h3 id="def-initself-x-9">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-9">self.val = x</h3>
    <h3 id="self.left-none-9">self.left = None</h3>
    <h3 id="self.right-none-9">self.right = None</h3>
    <p>
      class Solution(object): def hasPathSum(self, root, sum): :type root:
      TreeNode :type sum: int :rtype: bool if not root: return False
    </p>
    <div class="sourceCode" id="cb20">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb20-1" title="1">        <span class="cf">if</span> <span class="kw">not</span> root.left <span class="kw">and</span> <span class="kw">not</span> root.right <span class="kw">and</span> root.val <span class="op">==</span> <span class="bu">sum</span>:</a>
<a class="sourceLine" id="cb20-2" title="2">            <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb20-3" title="3"></a>
<a class="sourceLine" id="cb20-4" title="4">        <span class="cf">return</span> <span class="va">self</span>.hasPathSum(root.left, <span class="bu">sum</span> <span class="op">-</span> root.val) <span class="kw">or</span> <span class="va">self</span>.hasPathSum(</a>
<a class="sourceLine" id="cb20-5" title="5">            root.right, <span class="bu">sum</span> <span class="op">-</span> root.val</a>
<a class="sourceLine" id="cb20-6" title="6">        )</a></code></pre>
    </div>
    <h2
      id="given-a-binary-tree-and-a-sum-find-all-root-to-leaf-paths-where-each-paths-sum-equals-the-given-sum."
    >
      Given a binary tree and a sum, find all root-to-leaf paths where each
      path’s sum equals the given sum.
    </h2>
    <pre><code>Note: A leaf is a node with no children.

Example:

Given the below binary tree and sum = 22,

      5
     / \
    4   8
   /   / \
  11  13  4
 /  \    / \
7    2  5   1
Return:

[
   [5,4,11,2],
   [5,8,4,5]
]</code></pre>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-10">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-10">class TreeNode(object):</h3>
    <h3 id="def-initself-x-10">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-10">self.val = x</h3>
    <h3 id="self.left-none-10">self.left = None</h3>
    <h3 id="self.right-none-10">self.right = None</h3>
    <p>
      class Solution(object): def pathSum(self, root, sum): :type root: TreeNode
      :type sum: int :rtype: List[List[int]]
    </p>
    <div class="sourceCode" id="cb22">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb22-1" title="1">        result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb22-2" title="2"></a>
<a class="sourceLine" id="cb22-3" title="3">        <span class="kw">def</span> dfs(root, curr_sum, <span class="bu">sum</span>, path, result):</a>
<a class="sourceLine" id="cb22-4" title="4">            <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb22-5" title="5">                <span class="cf">return</span></a>
<a class="sourceLine" id="cb22-6" title="6"></a>
<a class="sourceLine" id="cb22-7" title="7">            curr_sum <span class="op">+=</span> root.val</a>
<a class="sourceLine" id="cb22-8" title="8">            <span class="cf">if</span> curr_sum <span class="op">==</span> <span class="bu">sum</span> <span class="kw">and</span> <span class="kw">not</span> root.left <span class="kw">and</span> <span class="kw">not</span> root.right:</a>
<a class="sourceLine" id="cb22-9" title="9">                result.append(path <span class="op">+</span> [root.val])</a>
<a class="sourceLine" id="cb22-10" title="10">                <span class="cf">return</span></a>
<a class="sourceLine" id="cb22-11" title="11"></a>
<a class="sourceLine" id="cb22-12" title="12">            <span class="cf">if</span> root.left:</a>
<a class="sourceLine" id="cb22-13" title="13">                dfs(root.left, curr_sum, <span class="bu">sum</span>, path <span class="op">+</span> [root.val], result)</a>
<a class="sourceLine" id="cb22-14" title="14">            <span class="cf">if</span> root.right:</a>
<a class="sourceLine" id="cb22-15" title="15">                dfs(root.right, curr_sum, <span class="bu">sum</span>, path <span class="op">+</span> [root.val], result)</a>
<a class="sourceLine" id="cb22-16" title="16"></a>
<a class="sourceLine" id="cb22-17" title="17">        dfs(root, <span class="dv">0</span>, <span class="bu">sum</span>, [], result)</a>
<a class="sourceLine" id="cb22-18" title="18">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <h2
      id="given-a-string-s-and-a-string-t-count-the-number-of-distinct-subsequences-of-s-which-equals-t."
    >
      Given a string S and a string T, count the number of distinct subsequences
      of S which equals T.
    </h2>
    <pre><code>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, &quot;ACE&quot; is a subsequence of &quot;ABCDE&quot; while &quot;AEC&quot; is not).

Example 1:

Input: S = &quot;rabbbit&quot;, T = &quot;rabbit&quot;
Output: 3
Explanation:

As shown below, there are 3 ways you can generate &quot;rabbit&quot; from S.
(The caret symbol ^ means the chosen letters)

rabbbit
^^^^ ^^
rabbbit
^^ ^^^^
rabbbit
^^^ ^^^</code></pre>
    <p>
      class Solution(object): def numDistinct(self, s, t): :type s: str :type t:
      str :rtype: int
    </p>
    <div class="sourceCode" id="cb24">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb24-1" title="1">        row, col <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</a>
<a class="sourceLine" id="cb24-2" title="2"></a>
<a class="sourceLine" id="cb24-3" title="3">        <span class="cf">if</span> col <span class="op">&gt;</span> row:</a>
<a class="sourceLine" id="cb24-4" title="4">            <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb24-5" title="5"></a>
<a class="sourceLine" id="cb24-6" title="6">        dp <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(col <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(row <span class="op">+</span> <span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb24-7" title="7"></a>
<a class="sourceLine" id="cb24-8" title="8">        <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(row <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb24-9" title="9">            <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(col <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb24-10" title="10">                <span class="cf">if</span> r <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> c <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb24-11" title="11">                    dp[r][c] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb24-12" title="12">                <span class="cf">elif</span> r <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb24-13" title="13">                    dp[r][c] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb24-14" title="14">                <span class="cf">elif</span> c <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb24-15" title="15">                    dp[r][c] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb24-16" title="16">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb24-17" title="17">                    dp[r][c] <span class="op">=</span> dp[r <span class="op">-</span> <span class="dv">1</span>][c]</a>
<a class="sourceLine" id="cb24-18" title="18">                    <span class="cf">if</span> s[r <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[c <span class="op">-</span> <span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb24-19" title="19">                        dp[r][c] <span class="op">+=</span> dp[r <span class="op">-</span> <span class="dv">1</span>][c <span class="op">-</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb24-20" title="20">        <span class="cf">return</span> dp[row][col]</a></code></pre>
    </div>
    <p>’’’ Given a binary tree</p>
    <pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL
Example:

Given the following perfect binary tree,

     1
   /  \
  2    3
 / \  / \
4  5  6  7
After calling your function, the tree should look like:

     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \  / \
4-&gt;5-&gt;6-&gt;7 -&gt; NULL</code></pre>
    <p>’’’</p>
    <hr />
    <h3 id="definition-for-binary-tree-with-next-pointer.">
      Definition for binary tree with next pointer.
    </h3>
    <h3 id="class-treelinknode">class TreeLinkNode:</h3>
    <h3 id="def-initself-x-11">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-11">self.val = x</h3>
    <h3 id="self.left-none-11">self.left = None</h3>
    <h3 id="self.right-none-11">self.right = None</h3>
    <h3 id="self.next-none">self.next = None</h3>
    <p>
      class Solution: #
      <span class="citation" data-cites="param"
        ><span class="citation" data-cites="param">@param</span></span
      >
      root, a tree link node #
      <span class="citation" data-cites="return"
        ><span class="citation" data-cites="return">@return</span></span
      >
      nothing def connect(self, root): def recursive(node): if node is None:
      return
    </p>
    <div class="sourceCode" id="cb26">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb26-1" title="1">            <span class="cf">if</span> node.left:</a>
<a class="sourceLine" id="cb26-2" title="2">                node.left.<span class="bu">next</span> <span class="op">=</span> node.right</a>
<a class="sourceLine" id="cb26-3" title="3">            <span class="cf">if</span> node.right:</a>
<a class="sourceLine" id="cb26-4" title="4">                <span class="cf">if</span> node.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb26-5" title="5">                    node.right.<span class="bu">next</span> <span class="op">=</span> node.<span class="bu">next</span>.left</a>
<a class="sourceLine" id="cb26-6" title="6">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb26-7" title="7">                    node.right.<span class="bu">next</span>  <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb26-8" title="8">            recursive(node.left)</a>
<a class="sourceLine" id="cb26-9" title="9">            recursive(node.right)</a>
<a class="sourceLine" id="cb26-10" title="10"></a>
<a class="sourceLine" id="cb26-11" title="11">        <span class="cf">if</span> root <span class="op">!=</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb26-12" title="12">            root.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb26-13" title="13">            recursive(root)</a></code></pre>
    </div>
    <h2 id="given-a-binary-tree">Given a binary tree</h2>
    <pre><code>struct TreeLinkNode {
  TreeLinkNode *left;
  TreeLinkNode *right;
  TreeLinkNode *next;
}
Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.

Initially, all next pointers are set to NULL.

Example:

Given the following binary tree,

     1
   /  \
  2    3
 / \    \
4   5    7
After calling your function, the tree should look like:

     1 -&gt; NULL
   /  \
  2 -&gt; 3 -&gt; NULL
 / \    \
4-&gt; 5 -&gt; 7 -&gt; NULL</code></pre>
    <hr />
    <h3 id="definition-for-binary-tree-with-next-pointer.-1">
      Definition for binary tree with next pointer.
    </h3>
    <h3 id="class-treelinknode-1">class TreeLinkNode:</h3>
    <h3 id="def-initself-x-12">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-12">self.val = x</h3>
    <h3 id="self.left-none-12">self.left = None</h3>
    <h3 id="self.right-none-12">self.right = None</h3>
    <h3 id="self.next-none-1">self.next = None</h3>
    <p>
      class Solution: #
      <span class="citation" data-cites="param"
        ><span class="citation" data-cites="param">@param</span></span
      >
      root, a tree link node #
      <span class="citation" data-cites="return"
        ><span class="citation" data-cites="return">@return</span></span
      >
      nothing def connect(self, root): if root == None: return queue = [root]
      queue.append(None)
    </p>
    <div class="sourceCode" id="cb28">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb28-1" title="1">        <span class="cf">while</span> queue:</a>
<a class="sourceLine" id="cb28-2" title="2">            front <span class="op">=</span> queue.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb28-3" title="3">            <span class="cf">if</span> front <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</a>
<a class="sourceLine" id="cb28-4" title="4">                front.<span class="bu">next</span> <span class="op">=</span> queue[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb28-5" title="5">                <span class="cf">if</span> front.left:</a>
<a class="sourceLine" id="cb28-6" title="6">                    queue.append(front.left)</a>
<a class="sourceLine" id="cb28-7" title="7">                <span class="cf">if</span> front.right:</a>
<a class="sourceLine" id="cb28-8" title="8">                    queue.append(front.right)</a>
<a class="sourceLine" id="cb28-9" title="9">            <span class="cf">elif</span> queue:</a>
<a class="sourceLine" id="cb28-10" title="10">                queue.append(<span class="va">None</span>)</a></code></pre>
    </div>
    <hr />
    <h3 id="definition-for-binary-tree-with-next-pointer.-2">
      Definition for binary tree with next pointer.
    </h3>
    <h3 id="class-treelinknode-2">class TreeLinkNode:</h3>
    <h3 id="def-initself-x-13">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-13">self.val = x</h3>
    <h3 id="self.left-none-13">self.left = None</h3>
    <h3 id="self.right-none-13">self.right = None</h3>
    <h3 id="self.next-none-2">self.next = None</h3>
    <p>
      class Solution: #
      <span class="citation" data-cites="param"
        ><span class="citation" data-cites="param">@param</span></span
      >
      root, a tree link node #
      <span class="citation" data-cites="return"
        ><span class="citation" data-cites="return">@return</span></span
      >
      nothing def connect(self, root): if not root: return None
    </p>
    <div class="sourceCode" id="cb29">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb29-1" title="1">        root.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb29-2" title="2"></a>
<a class="sourceLine" id="cb29-3" title="3">        <span class="cf">while</span> root:</a>
<a class="sourceLine" id="cb29-4" title="4">            temp <span class="op">=</span> root</a>
<a class="sourceLine" id="cb29-5" title="5">            <span class="cf">while</span> temp:</a>
<a class="sourceLine" id="cb29-6" title="6">                <span class="cf">if</span> temp.left:</a>
<a class="sourceLine" id="cb29-7" title="7">                    <span class="cf">if</span> temp.right:</a>
<a class="sourceLine" id="cb29-8" title="8">                        temp.left.<span class="bu">next</span> <span class="op">=</span> temp.right</a>
<a class="sourceLine" id="cb29-9" title="9">                    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb29-10" title="10">                        temp.left.<span class="bu">next</span> <span class="op">=</span> <span class="va">self</span>.getNext(temp)</a>
<a class="sourceLine" id="cb29-11" title="11">                <span class="cf">if</span> temp.right:</a>
<a class="sourceLine" id="cb29-12" title="12">                    temp.right.<span class="bu">next</span> <span class="op">=</span> <span class="va">self</span>.getNext(temp)</a>
<a class="sourceLine" id="cb29-13" title="13"></a>
<a class="sourceLine" id="cb29-14" title="14">                temp <span class="op">=</span> temp.<span class="bu">next</span></a>
<a class="sourceLine" id="cb29-15" title="15">            <span class="cf">if</span> root.left:</a>
<a class="sourceLine" id="cb29-16" title="16">                root <span class="op">=</span> root.left</a>
<a class="sourceLine" id="cb29-17" title="17">            <span class="cf">elif</span> root.right:</a>
<a class="sourceLine" id="cb29-18" title="18">                root <span class="op">=</span> root.right</a>
<a class="sourceLine" id="cb29-19" title="19">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb29-20" title="20">                root <span class="op">=</span> <span class="va">self</span>.getNext(root)</a>
<a class="sourceLine" id="cb29-21" title="21"></a>
<a class="sourceLine" id="cb29-22" title="22">    <span class="kw">def</span> getNext(<span class="va">self</span>, node):</a>
<a class="sourceLine" id="cb29-23" title="23">        node <span class="op">=</span> node.<span class="bu">next</span></a>
<a class="sourceLine" id="cb29-24" title="24">        <span class="cf">while</span> node:</a>
<a class="sourceLine" id="cb29-25" title="25">            <span class="cf">if</span> node.left:</a>
<a class="sourceLine" id="cb29-26" title="26">                <span class="cf">return</span> node.left</a>
<a class="sourceLine" id="cb29-27" title="27">            <span class="cf">if</span> node.right:</a>
<a class="sourceLine" id="cb29-28" title="28">                <span class="cf">return</span> node.right</a>
<a class="sourceLine" id="cb29-29" title="29">            node <span class="op">=</span> node.<span class="bu">next</span></a>
<a class="sourceLine" id="cb29-30" title="30">        <span class="cf">return</span> <span class="va">None</span></a></code></pre>
    </div>
    <h2
      id="given-a-non-negative-integer-numrows-generate-the-first-numrows-of-pascals-triangle."
    >
      Given a non-negative integer numRows, generate the first numRows of
      Pascal’s triangle.
    </h2>
    <pre><code>Example:

Input: 5
Output:
[
     [1],
    [1,1],
   [1,2,1],
  [1,3,3,1],
 [1,4,6,4,1]
]</code></pre>
    <p>
      class Solution(object): def generate(self, numRows): :type numRows: int
      :rtype: List[List[int]] triangle = []
    </p>
    <div class="sourceCode" id="cb31">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb31-1" title="1">        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(numRows):</a>
<a class="sourceLine" id="cb31-2" title="2">            new_row <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(row <span class="op">+</span> <span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb31-3" title="3">            new_row[<span class="dv">0</span>], new_row[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> <span class="dv">1</span>, <span class="dv">1</span></a>
<a class="sourceLine" id="cb31-4" title="4"></a>
<a class="sourceLine" id="cb31-5" title="5">            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(new_row) <span class="op">-</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb31-6" title="6">                new_row[col] <span class="op">=</span> triangle[row <span class="op">-</span> <span class="dv">1</span>][col <span class="op">-</span> <span class="dv">1</span>] <span class="op">+</span> triangle[row <span class="op">-</span> <span class="dv">1</span>][col]</a>
<a class="sourceLine" id="cb31-7" title="7">            triangle.append(new_row)</a>
<a class="sourceLine" id="cb31-8" title="8">        <span class="cf">return</span> triangle</a></code></pre>
    </div>
    <h2
      id="given-a-non-negative-index-k-where-k-33-return-the-kth-index-row-of-the-pascals-triangle."
    >
      Given a non-negative index k where k ≤ 33, return the kth index row of the
      Pascal’s triangle.
    </h2>
    <pre><code>Note that the row index starts from 0.</code></pre>
    <p>
      class Solution(object): def getRow(self, rowIndex): :type rowIndex: int
      :rtype: List[int] row = [1] * (rowIndex + 1) for i in range(1, rowIndex +
      1): for j in range(i - 1, 0, -1): row[j] += row[j - 1] return row
    </p>
    <pre><code>
---

```py

## Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.

    For example, given the following triangle

    [
         [2],
        [3,4],
       [6,5,7],
      [4,1,8,3]
    ]
    The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11).



class Solution(object): def minimumTotal(self, triangle):  :type triangle: List[List[int]] :rtype: int  length = len(triangle) columns = len(triangle[length - 1])
```py
        matrix = [[0 for col in range(columns)] for row in range(length)]
        row_index = 0

        for row in range(length):
            elements = triangle[row]
            col_index = 0

            for val in elements:
                matrix[row_index][col_index] = val
                col_index += 1
            row_index += 1

        for row in range(length - 2, -1, -1):
            for col in range(row + 1):
                matrix[row][col] += min(matrix[row + 1][col + 1], matrix[row + 1][col])
        return matrix[0][0]</code></pre>
    <div class="sourceCode" id="cb34">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb34-1" title="1"> Say you have an array <span class="cf">for</span> which the ith element <span class="kw">is</span> the price of a given stock on day i.</a>
<a class="sourceLine" id="cb34-2" title="2"></a>
<a class="sourceLine" id="cb34-3" title="3">    Design an algorithm to find the maximum profit. You may complete at most two transactions.</a>
<a class="sourceLine" id="cb34-4" title="4"></a>
<a class="sourceLine" id="cb34-5" title="5">    Note: You may <span class="kw">not</span> engage <span class="kw">in</span> multiple transactions at the same time (i.e., you must sell the stock before you buy again).</a>
<a class="sourceLine" id="cb34-6" title="6"></a>
<a class="sourceLine" id="cb34-7" title="7">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb34-8" title="8"></a>
<a class="sourceLine" id="cb34-9" title="9">    Input: [<span class="dv">3</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">1</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb34-10" title="10">    Output: <span class="dv">6</span></a>
<a class="sourceLine" id="cb34-11" title="11">    Explanation: Buy on day <span class="dv">4</span> (price <span class="op">=</span> <span class="dv">0</span>) <span class="kw">and</span> sell on day <span class="dv">6</span> (price <span class="op">=</span> <span class="dv">3</span>), profit <span class="op">=</span> <span class="dv">3-0</span> <span class="op">=</span> <span class="fl">3.</span></a>
<a class="sourceLine" id="cb34-12" title="12">                 Then buy on day <span class="dv">7</span> (price <span class="op">=</span> <span class="dv">1</span>) <span class="kw">and</span> sell on day <span class="dv">8</span> (price <span class="op">=</span> <span class="dv">4</span>), profit <span class="op">=</span> <span class="dv">4-1</span> <span class="op">=</span> <span class="fl">3.</span></a>
<a class="sourceLine" id="cb34-13" title="13"></a>
<a class="sourceLine" id="cb34-14" title="14"></a>
<a class="sourceLine" id="cb34-15" title="15"></a>
<a class="sourceLine" id="cb34-16" title="16"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> maxProfit(<span class="va">self</span>, prices):  :<span class="bu">type</span> prices: List[<span class="bu">int</span>] :rtype: <span class="bu">int</span>  <span class="cf">if</span> <span class="bu">len</span>(prices) <span class="op">&lt;</span> <span class="dv">2</span>: <span class="cf">return</span> <span class="dv">0</span> dp <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(prices))] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">3</span>)] <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">3</span>): maxDiff <span class="op">=</span> <span class="op">-</span>prices[<span class="dv">0</span>] <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(prices)): dp[i][j] <span class="op">=</span> <span class="bu">max</span>(dp[i][j <span class="op">-</span> <span class="dv">1</span>], prices[j] <span class="op">+</span> maxDiff) maxDiff <span class="op">=</span> <span class="bu">max</span>(maxDiff, dp[i <span class="op">-</span> <span class="dv">1</span>][j] <span class="op">-</span> prices[j])</a>
<a class="sourceLine" id="cb34-17" title="17"></a>
<a class="sourceLine" id="cb34-18" title="18">        <span class="cf">return</span> dp[<span class="dv">2</span>][<span class="bu">len</span>(prices) <span class="op">-</span> <span class="dv">1</span>]</a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb35">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb35-1" title="1"></a>
<a class="sourceLine" id="cb35-2" title="2"><span class="co">## Given a non-empty binary tree, find the maximum path sum.</span></a>
<a class="sourceLine" id="cb35-3" title="3"></a>
<a class="sourceLine" id="cb35-4" title="4">    For this problem, a path <span class="kw">is</span> defined <span class="im">as</span> <span class="bu">any</span> sequence of nodes <span class="im">from</span> some starting node to <span class="bu">any</span> node <span class="kw">in</span> the tree along the parent<span class="op">-</span>child connections. The path must contain at least one node <span class="kw">and</span> does <span class="kw">not</span> need to go through the root.</a>
<a class="sourceLine" id="cb35-5" title="5"></a>
<a class="sourceLine" id="cb35-6" title="6">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb35-7" title="7"></a>
<a class="sourceLine" id="cb35-8" title="8">    Input: [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb35-9" title="9"></a>
<a class="sourceLine" id="cb35-10" title="10">           <span class="dv">1</span></a>
<a class="sourceLine" id="cb35-11" title="11">          <span class="op">/</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb35-12" title="12">         <span class="dv">2</span>   <span class="dv">3</span></a>
<a class="sourceLine" id="cb35-13" title="13"></a>
<a class="sourceLine" id="cb35-14" title="14">    Output: <span class="dv">6</span></a>
<a class="sourceLine" id="cb35-15" title="15">    Example <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb35-16" title="16"></a>
<a class="sourceLine" id="cb35-17" title="17">    Input: [<span class="op">-</span><span class="dv">10</span>,<span class="dv">9</span>,<span class="dv">20</span>,null,null,<span class="dv">15</span>,<span class="dv">7</span>]</a>
<a class="sourceLine" id="cb35-18" title="18"></a>
<a class="sourceLine" id="cb35-19" title="19">       <span class="dv">-10</span></a>
<a class="sourceLine" id="cb35-20" title="20">       <span class="op">/</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb35-21" title="21">      <span class="dv">9</span>  <span class="dv">20</span></a>
<a class="sourceLine" id="cb35-22" title="22">        <span class="op">/</span>  <span class="op">\</span></a>
<a class="sourceLine" id="cb35-23" title="23">       <span class="dv">15</span>   <span class="dv">7</span></a>
<a class="sourceLine" id="cb35-24" title="24"></a>
<a class="sourceLine" id="cb35-25" title="25">    Output: <span class="dv">42</span></a>
<a class="sourceLine" id="cb35-26" title="26"></a></code></pre>
    </div>
    <hr />
    <h3 id="definition-for-a-binary-tree-node.-11">
      Definition for a binary tree node.
    </h3>
    <h3 id="class-treenodeobject-11">class TreeNode(object):</h3>
    <h3 id="def-initself-x-14">def <strong>init</strong>(self, x):</h3>
    <h3 id="self.val-x-14">self.val = x</h3>
    <h3 id="self.left-none-14">self.left = None</h3>
    <h3 id="self.right-none-14">self.right = None</h3>
    <div class="sourceCode" id="cb36">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb36-1" title="1"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> maxPathSum(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: <span class="bu">int</span>  <span class="va">self</span>.result <span class="op">=</span> <span class="bu">float</span>(“<span class="op">-</span>inf”) <span class="va">self</span>.dfs(root) <span class="cf">return</span> <span class="va">self</span>.result</a>
<a class="sourceLine" id="cb36-2" title="2"></a>
<a class="sourceLine" id="cb36-3" title="3">    <span class="kw">def</span> dfs(<span class="va">self</span>, root):</a>
<a class="sourceLine" id="cb36-4" title="4">        <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb36-5" title="5">            <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb36-6" title="6"></a>
<a class="sourceLine" id="cb36-7" title="7">        l <span class="op">=</span> <span class="va">self</span>.dfs(root.left)</a>
<a class="sourceLine" id="cb36-8" title="8">        r <span class="op">=</span> <span class="va">self</span>.dfs(root.right)</a>
<a class="sourceLine" id="cb36-9" title="9"></a>
<a class="sourceLine" id="cb36-10" title="10">        max_one_end <span class="op">=</span> <span class="bu">max</span>(<span class="bu">max</span>(l, r) <span class="op">+</span> root.val, root.val)</a>
<a class="sourceLine" id="cb36-11" title="11">        max_path <span class="op">=</span> <span class="bu">max</span>(max_one_end, l <span class="op">+</span> r <span class="op">+</span> root.val)</a>
<a class="sourceLine" id="cb36-12" title="12">        <span class="va">self</span>.result <span class="op">=</span> <span class="bu">max</span>(<span class="va">self</span>.result, max_path)</a>
<a class="sourceLine" id="cb36-13" title="13">        <span class="cf">return</span> max_one_end</a>
<a class="sourceLine" id="cb36-14" title="14"></a>
<a class="sourceLine" id="cb36-15" title="15"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> numDistinct(<span class="va">self</span>, s, t):  :<span class="bu">type</span> s: <span class="bu">str</span> :<span class="bu">type</span> t: <span class="bu">str</span> :rtype: <span class="bu">int</span></a>
<a class="sourceLine" id="cb36-16" title="16"></a>
<a class="sourceLine" id="cb36-17" title="17">        row, col <span class="op">=</span> <span class="bu">len</span>(s), <span class="bu">len</span>(t)</a>
<a class="sourceLine" id="cb36-18" title="18"></a>
<a class="sourceLine" id="cb36-19" title="19">        <span class="cf">if</span> col <span class="op">&gt;</span> row:</a>
<a class="sourceLine" id="cb36-20" title="20">            <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb36-21" title="21"></a>
<a class="sourceLine" id="cb36-22" title="22">        dp <span class="op">=</span> [[<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(col <span class="op">+</span> <span class="dv">1</span>)] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(row <span class="op">+</span> <span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb36-23" title="23"></a>
<a class="sourceLine" id="cb36-24" title="24">        <span class="cf">for</span> r <span class="kw">in</span> <span class="bu">range</span>(row <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb36-25" title="25">            <span class="cf">for</span> c <span class="kw">in</span> <span class="bu">range</span>(col <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb36-26" title="26">                <span class="cf">if</span> r <span class="op">==</span> <span class="dv">0</span> <span class="kw">and</span> c <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb36-27" title="27">                    dp[r][c] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb36-28" title="28">                <span class="cf">elif</span> r <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb36-29" title="29">                    dp[r][c] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb36-30" title="30">                <span class="cf">elif</span> c <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb36-31" title="31">                    dp[r][c] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb36-32" title="32">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb36-33" title="33">                    dp[r][c] <span class="op">=</span> dp[r <span class="op">-</span> <span class="dv">1</span>][c]</a>
<a class="sourceLine" id="cb36-34" title="34">                    <span class="cf">if</span> s[r <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> t[c <span class="op">-</span> <span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb36-35" title="35">                        dp[r][c] <span class="op">+=</span> dp[r <span class="op">-</span> <span class="dv">1</span>][c <span class="op">-</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb36-36" title="36">        <span class="cf">return</span> dp[row][col]</a>
<a class="sourceLine" id="cb36-37" title="37"></a>
<a class="sourceLine" id="cb36-38" title="38"><span class="co">### Time: O(N^2)</span></a>
<a class="sourceLine" id="cb36-39" title="39"></a>
<a class="sourceLine" id="cb36-40" title="40"><span class="co">### Space: O(N^2)</span></a></code></pre>
    </div>
    <div class="sourceCode" id="cb37">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb37-1" title="1">’’’ Given two words (beginWord <span class="kw">and</span> endWord), <span class="kw">and</span> a dictionary’s word <span class="bu">list</span>, find the length of shortest transformation sequence <span class="im">from</span> beginWord to endWord, such that:</a>
<a class="sourceLine" id="cb37-2" title="2"></a>
<a class="sourceLine" id="cb37-3" title="3">    Only one letter can be changed at a time.</a>
<a class="sourceLine" id="cb37-4" title="4">    Each transformed word must exist <span class="kw">in</span> the word <span class="bu">list</span>. Note that beginWord <span class="kw">is</span> <span class="kw">not</span> a transformed word.</a>
<a class="sourceLine" id="cb37-5" title="5">    Note:</a>
<a class="sourceLine" id="cb37-6" title="6"></a>
<a class="sourceLine" id="cb37-7" title="7">    Return <span class="dv">0</span> <span class="cf">if</span> there <span class="kw">is</span> no such transformation sequence.</a>
<a class="sourceLine" id="cb37-8" title="8">    All words have the same length.</a>
<a class="sourceLine" id="cb37-9" title="9">    All words contain only lowercase alphabetic characters.</a>
<a class="sourceLine" id="cb37-10" title="10">    You may assume no duplicates <span class="kw">in</span> the word <span class="bu">list</span>.</a>
<a class="sourceLine" id="cb37-11" title="11">    You may assume beginWord <span class="kw">and</span> endWord are non<span class="op">-</span>empty <span class="kw">and</span> are <span class="kw">not</span> the same.</a>
<a class="sourceLine" id="cb37-12" title="12">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb37-13" title="13"></a>
<a class="sourceLine" id="cb37-14" title="14">    Input:</a>
<a class="sourceLine" id="cb37-15" title="15">    beginWord <span class="op">=</span> <span class="st">&quot;hit&quot;</span>,</a>
<a class="sourceLine" id="cb37-16" title="16">    endWord <span class="op">=</span> <span class="st">&quot;cog&quot;</span>,</a>
<a class="sourceLine" id="cb37-17" title="17">    wordList <span class="op">=</span> [<span class="st">&quot;hot&quot;</span>,<span class="st">&quot;dot&quot;</span>,<span class="st">&quot;dog&quot;</span>,<span class="st">&quot;lot&quot;</span>,<span class="st">&quot;log&quot;</span>,<span class="st">&quot;cog&quot;</span>]</a>
<a class="sourceLine" id="cb37-18" title="18"></a>
<a class="sourceLine" id="cb37-19" title="19">    Output: <span class="dv">5</span></a>
<a class="sourceLine" id="cb37-20" title="20"></a>
<a class="sourceLine" id="cb37-21" title="21">    Explanation: As one shortest transformation <span class="kw">is</span> <span class="st">&quot;hit&quot;</span> <span class="op">-&gt;</span> <span class="st">&quot;hot&quot;</span> <span class="op">-&gt;</span> <span class="st">&quot;dot&quot;</span> <span class="op">-&gt;</span> <span class="st">&quot;dog&quot;</span> <span class="op">-&gt;</span> <span class="st">&quot;cog&quot;</span>,</a>
<a class="sourceLine" id="cb37-22" title="22">    <span class="cf">return</span> its length <span class="fl">5.</span></a>
<a class="sourceLine" id="cb37-23" title="23"></a>
<a class="sourceLine" id="cb37-24" title="24">’’’</a>
<a class="sourceLine" id="cb37-25" title="25"></a>
<a class="sourceLine" id="cb37-26" title="26"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> ladderLength(<span class="va">self</span>, beginWord, endWord, wordList):  :<span class="bu">type</span> beginWord: <span class="bu">str</span> :<span class="bu">type</span> endWord: <span class="bu">str</span> :<span class="bu">type</span> wordList: List[<span class="bu">str</span>] :rtype: <span class="bu">int</span>  d <span class="op">=</span> {} <span class="cf">for</span> word <span class="kw">in</span> wordList: <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(word)): s <span class="op">=</span> word[:i] <span class="op">+</span> <span class="st">&quot;_&quot;</span> <span class="op">+</span> word[i<span class="op">+</span><span class="dv">1</span>:] <span class="cf">if</span> s <span class="kw">in</span> d: d[s].append(word) <span class="cf">else</span>: d[s] <span class="op">=</span> [word] <span class="bu">print</span> d queue, visited <span class="op">=</span> [], <span class="bu">set</span>() queue.append((beginWord, <span class="dv">1</span>)) <span class="cf">while</span> queue: word, steps <span class="op">=</span> queue.pop(<span class="dv">0</span>) <span class="cf">if</span> word <span class="kw">not</span> <span class="kw">in</span> visited: visited.add(word)</a>
<a class="sourceLine" id="cb37-27" title="27"></a>
<a class="sourceLine" id="cb37-28" title="28">                <span class="cf">if</span> word <span class="op">==</span> endWord:</a>
<a class="sourceLine" id="cb37-29" title="29">                    <span class="cf">return</span> steps</a>
<a class="sourceLine" id="cb37-30" title="30">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb37-31" title="31">                    <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(word)):</a>
<a class="sourceLine" id="cb37-32" title="32">                        s <span class="op">=</span> word[:index] <span class="op">+</span> <span class="st">&quot;_&quot;</span> <span class="op">+</span> word[index<span class="op">+</span><span class="dv">1</span>:]</a>
<a class="sourceLine" id="cb37-33" title="33">                        neigh_words <span class="op">=</span> []</a>
<a class="sourceLine" id="cb37-34" title="34">                        <span class="cf">if</span> s <span class="kw">in</span> d:</a>
<a class="sourceLine" id="cb37-35" title="35">                            neigh_words <span class="op">=</span> d[s]</a>
<a class="sourceLine" id="cb37-36" title="36"></a>
<a class="sourceLine" id="cb37-37" title="37">                        <span class="cf">for</span> neigh <span class="kw">in</span> neigh_words:</a>
<a class="sourceLine" id="cb37-38" title="38">                            <span class="cf">if</span> neigh <span class="kw">not</span> <span class="kw">in</span> visited:</a>
<a class="sourceLine" id="cb37-39" title="39">                                queue.append((neigh, steps<span class="op">+</span><span class="dv">1</span>))</a>
<a class="sourceLine" id="cb37-40" title="40">        <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb37-41" title="41"></a>
<a class="sourceLine" id="cb37-42" title="42">Solution().ladderLength(“hit”, “cog”, [“hot”,“dot”,“dog”,“lot”,“log”,“cog”] ) <span class="co">## Given an unsorted array of integers, find the length of the longest consecutive elements sequence.</span></a>
<a class="sourceLine" id="cb37-43" title="43"></a>
<a class="sourceLine" id="cb37-44" title="44">    Your algorithm should run <span class="kw">in</span> O(n) complexity.</a>
<a class="sourceLine" id="cb37-45" title="45"></a>
<a class="sourceLine" id="cb37-46" title="46">    Example:</a>
<a class="sourceLine" id="cb37-47" title="47"></a>
<a class="sourceLine" id="cb37-48" title="48">    Input: [<span class="dv">100</span>, <span class="dv">4</span>, <span class="dv">200</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb37-49" title="49">    Output: <span class="dv">4</span></a>
<a class="sourceLine" id="cb37-50" title="50">    Explanation: The longest consecutive elements sequence <span class="kw">is</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]. Therefore its length <span class="kw">is</span> <span class="fl">4.</span></a>
<a class="sourceLine" id="cb37-51" title="51"></a>
<a class="sourceLine" id="cb37-52" title="52"></a>
<a class="sourceLine" id="cb37-53" title="53"></a>
<a class="sourceLine" id="cb37-54" title="54"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> longestConsecutive(<span class="va">self</span>, nums):  :<span class="bu">type</span> nums: List[<span class="bu">int</span>] :rtype: <span class="bu">int</span>  result <span class="op">=</span> <span class="dv">0</span> nums <span class="op">=</span> <span class="bu">set</span>(nums)</a>
<a class="sourceLine" id="cb37-55" title="55"></a>
<a class="sourceLine" id="cb37-56" title="56">        <span class="cf">for</span> num <span class="kw">in</span> nums:</a>
<a class="sourceLine" id="cb37-57" title="57">            <span class="cf">if</span> num <span class="op">-</span> <span class="dv">1</span> <span class="kw">not</span> <span class="kw">in</span> nums:</a>
<a class="sourceLine" id="cb37-58" title="58">                curr <span class="op">=</span> num</a>
<a class="sourceLine" id="cb37-59" title="59">                length <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb37-60" title="60"></a>
<a class="sourceLine" id="cb37-61" title="61">                <span class="cf">while</span> curr <span class="op">+</span> <span class="dv">1</span> <span class="kw">in</span> nums:</a>
<a class="sourceLine" id="cb37-62" title="62">                    curr <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb37-63" title="63">                    length <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb37-64" title="64">                result <span class="op">=</span> <span class="bu">max</span>(result, length)</a>
<a class="sourceLine" id="cb37-65" title="65">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb38">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb38-1" title="1"></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="co">## Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.</span></a>
<a class="sourceLine" id="cb38-3" title="3"></a>
<a class="sourceLine" id="cb38-4" title="4">An example <span class="kw">is</span> the root<span class="op">-</span>to<span class="op">-</span>leaf path <span class="dv">1</span><span class="op">-&gt;</span><span class="dv">2</span><span class="op">-&gt;</span><span class="dv">3</span> which represents the number <span class="fl">123.</span></a>
<a class="sourceLine" id="cb38-5" title="5"></a>
<a class="sourceLine" id="cb38-6" title="6">Find the total <span class="bu">sum</span> of <span class="bu">all</span> root<span class="op">-</span>to<span class="op">-</span>leaf numbers.</a>
<a class="sourceLine" id="cb38-7" title="7"></a>
<a class="sourceLine" id="cb38-8" title="8">Note: A leaf <span class="kw">is</span> a node <span class="cf">with</span> no children.</a>
<a class="sourceLine" id="cb38-9" title="9"></a>
<a class="sourceLine" id="cb38-10" title="10">Example:</a>
<a class="sourceLine" id="cb38-11" title="11"></a>
<a class="sourceLine" id="cb38-12" title="12">Input: [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>] <span class="dv">1</span> <span class="op">/</span></a>
<a class="sourceLine" id="cb38-13" title="13"><span class="dv">2</span> <span class="dv">3</span> Output: <span class="dv">25</span> Explanation: The root<span class="op">-</span>to<span class="op">-</span>leaf path <span class="dv">1</span><span class="op">-&gt;</span><span class="dv">2</span> represents the number <span class="dv">12</span><span class="op">\</span>. The root<span class="op">-</span>to<span class="op">-</span>leaf path <span class="dv">1</span><span class="op">-&gt;</span><span class="dv">3</span> represents the number <span class="dv">13</span><span class="op">\</span>. Therefore, <span class="bu">sum</span> <span class="op">=</span> <span class="dv">12</span> <span class="op">+</span> <span class="dv">13</span> <span class="op">=</span> <span class="dv">25</span><span class="op">\</span>.</a>
<a class="sourceLine" id="cb38-14" title="14"></a>
<a class="sourceLine" id="cb38-15" title="15"><span class="op">---</span></a>
<a class="sourceLine" id="cb38-16" title="16"></a>
<a class="sourceLine" id="cb38-17" title="17"><span class="co">### Definition for a binary tree node.</span></a>
<a class="sourceLine" id="cb38-18" title="18"></a>
<a class="sourceLine" id="cb38-19" title="19"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb38-20" title="20"></a>
<a class="sourceLine" id="cb38-21" title="21"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb38-22" title="22"></a>
<a class="sourceLine" id="cb38-23" title="23"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb38-24" title="24"></a>
<a class="sourceLine" id="cb38-25" title="25"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb38-26" title="26"></a>
<a class="sourceLine" id="cb38-27" title="27"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb38-28" title="28"></a>
<a class="sourceLine" id="cb38-29" title="29"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> sumNumbers(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: <span class="bu">int</span>  <span class="cf">if</span> <span class="kw">not</span> root: <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb38-30" title="30"></a>
<a class="sourceLine" id="cb38-31" title="31">        <span class="kw">def</span> dfs(root, num, total):</a>
<a class="sourceLine" id="cb38-32" title="32">            <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb38-33" title="33">                <span class="cf">return</span> total</a>
<a class="sourceLine" id="cb38-34" title="34">            num <span class="op">=</span> num <span class="op">*</span> <span class="dv">10</span> <span class="op">+</span> root.val</a>
<a class="sourceLine" id="cb38-35" title="35">            <span class="cf">if</span> <span class="kw">not</span> root.left <span class="kw">and</span> <span class="kw">not</span> root.right:</a>
<a class="sourceLine" id="cb38-36" title="36">                total <span class="op">+=</span> num</a>
<a class="sourceLine" id="cb38-37" title="37">                <span class="cf">return</span> total</a>
<a class="sourceLine" id="cb38-38" title="38"></a>
<a class="sourceLine" id="cb38-39" title="39">            <span class="cf">return</span> dfs(root.left, num) <span class="op">+</span> dfs(root.right, num)</a>
<a class="sourceLine" id="cb38-40" title="40"></a>
<a class="sourceLine" id="cb38-41" title="41">        <span class="cf">return</span> dfs(root, <span class="dv">0</span>, <span class="dv">0</span>)</a></code></pre>
    </div>
    <div class="sourceCode" id="cb39">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb39-1" title="1"><span class="co">## Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</span></a>
<a class="sourceLine" id="cb39-2" title="2"></a>
<a class="sourceLine" id="cb39-3" title="3">    A region <span class="kw">is</span> captured by flipping <span class="bu">all</span> <span class="st">&#39;O&#39;</span>s into <span class="st">&#39;X&#39;</span>s <span class="kw">in</span> that surrounded region.</a>
<a class="sourceLine" id="cb39-4" title="4"></a>
<a class="sourceLine" id="cb39-5" title="5">    Example:</a>
<a class="sourceLine" id="cb39-6" title="6"></a>
<a class="sourceLine" id="cb39-7" title="7">    X X X X</a>
<a class="sourceLine" id="cb39-8" title="8">    X O O X</a>
<a class="sourceLine" id="cb39-9" title="9">    X X O X</a>
<a class="sourceLine" id="cb39-10" title="10">    X O X X</a>
<a class="sourceLine" id="cb39-11" title="11">    After running your function, the board should be:</a>
<a class="sourceLine" id="cb39-12" title="12"></a>
<a class="sourceLine" id="cb39-13" title="13">    X X X X</a>
<a class="sourceLine" id="cb39-14" title="14">    X X X X</a>
<a class="sourceLine" id="cb39-15" title="15">    X X X X</a>
<a class="sourceLine" id="cb39-16" title="16">    X O X X</a>
<a class="sourceLine" id="cb39-17" title="17"></a>
<a class="sourceLine" id="cb39-18" title="18"></a>
<a class="sourceLine" id="cb39-19" title="19"></a>
<a class="sourceLine" id="cb39-20" title="20"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> solve(<span class="va">self</span>, board):  :<span class="bu">type</span> board: List[List[<span class="bu">str</span>]] :rtype: void Do <span class="kw">not</span> <span class="cf">return</span> anything, modify board <span class="kw">in</span><span class="op">-</span>place instead.  <span class="cf">if</span> <span class="bu">len</span>(board) <span class="op">==</span> <span class="dv">0</span>: <span class="cf">return</span> <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(board)): <span class="cf">if</span> board[row][<span class="dv">0</span>] <span class="op">==</span> “O”: <span class="va">self</span>.merge(board, row, <span class="dv">0</span>) <span class="cf">if</span> board[row][<span class="bu">len</span>(board[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>] <span class="op">==</span> “O”: <span class="va">self</span>.merge(board, row, <span class="bu">len</span>(board[<span class="dv">0</span>]) <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb39-21" title="21"></a>
<a class="sourceLine" id="cb39-22" title="22">        <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(board[<span class="dv">0</span>])):</a>
<a class="sourceLine" id="cb39-23" title="23">            <span class="cf">if</span> board[<span class="dv">0</span>][col] <span class="op">==</span> <span class="st">&quot;O&quot;</span>:</a>
<a class="sourceLine" id="cb39-24" title="24">                <span class="va">self</span>.merge(board, <span class="dv">0</span>, col)</a>
<a class="sourceLine" id="cb39-25" title="25"></a>
<a class="sourceLine" id="cb39-26" title="26">            <span class="cf">if</span> board[<span class="bu">len</span>(board) <span class="op">-</span> <span class="dv">1</span>][col] <span class="op">==</span> <span class="st">&quot;O&quot;</span>:</a>
<a class="sourceLine" id="cb39-27" title="27">                <span class="va">self</span>.merge(board, <span class="bu">len</span>(board) <span class="op">-</span> <span class="dv">1</span>, col)</a>
<a class="sourceLine" id="cb39-28" title="28"></a>
<a class="sourceLine" id="cb39-29" title="29">        <span class="cf">for</span> row <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(board)):</a>
<a class="sourceLine" id="cb39-30" title="30">            <span class="cf">for</span> col <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(board[<span class="dv">0</span>])):</a>
<a class="sourceLine" id="cb39-31" title="31">                <span class="cf">if</span> board[row][col] <span class="op">==</span> <span class="st">&quot;O&quot;</span>:</a>
<a class="sourceLine" id="cb39-32" title="32">                    board[row][col] <span class="op">=</span> <span class="st">&quot;X&quot;</span></a>
<a class="sourceLine" id="cb39-33" title="33">                <span class="cf">elif</span> board[row][col] <span class="op">==</span> <span class="st">&quot;#&quot;</span>:</a>
<a class="sourceLine" id="cb39-34" title="34">                    board[row][col] <span class="op">=</span> <span class="st">&quot;O&quot;</span></a>
<a class="sourceLine" id="cb39-35" title="35"></a>
<a class="sourceLine" id="cb39-36" title="36">    <span class="kw">def</span> merge(<span class="va">self</span>, board, row, col):</a>
<a class="sourceLine" id="cb39-37" title="37">        <span class="cf">if</span> row <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> col <span class="op">&lt;</span> <span class="dv">0</span> <span class="kw">or</span> row <span class="op">&gt;=</span> <span class="bu">len</span>(board) <span class="kw">or</span> col <span class="op">&gt;=</span> <span class="bu">len</span>(board[<span class="dv">0</span>]):</a>
<a class="sourceLine" id="cb39-38" title="38">            <span class="cf">return</span></a>
<a class="sourceLine" id="cb39-39" title="39">        <span class="cf">if</span> board[row][col] <span class="op">!=</span> <span class="st">&quot;O&quot;</span>:</a>
<a class="sourceLine" id="cb39-40" title="40">            <span class="cf">return</span></a>
<a class="sourceLine" id="cb39-41" title="41"></a>
<a class="sourceLine" id="cb39-42" title="42">        board[row][col] <span class="op">=</span> <span class="st">&quot;#&quot;</span></a>
<a class="sourceLine" id="cb39-43" title="43">        <span class="va">self</span>.merge(board, row <span class="op">+</span> <span class="dv">1</span>, col)</a>
<a class="sourceLine" id="cb39-44" title="44">        <span class="va">self</span>.merge(board, row, col <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb39-45" title="45">        <span class="va">self</span>.merge(board, row, col <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb39-46" title="46">        <span class="va">self</span>.merge(board, row <span class="op">-</span> <span class="dv">1</span>, col)</a></code></pre>
    </div>
    <div class="sourceCode" id="cb40">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb40-1" title="1"><span class="co">## Given a string s, partition s such that every substring of the partition is a palindrome.</span></a>
<a class="sourceLine" id="cb40-2" title="2"></a>
<a class="sourceLine" id="cb40-3" title="3">    Return <span class="bu">all</span> possible palindrome partitioning of s.</a>
<a class="sourceLine" id="cb40-4" title="4"></a>
<a class="sourceLine" id="cb40-5" title="5"></a>
<a class="sourceLine" id="cb40-6" title="6"></a>
<a class="sourceLine" id="cb40-7" title="7"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> partition(<span class="va">self</span>, s): result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb40-8" title="8"></a>
<a class="sourceLine" id="cb40-9" title="9">        <span class="kw">def</span> valid(s):</a>
<a class="sourceLine" id="cb40-10" title="10">            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s) <span class="op">/</span> <span class="dv">2</span>):</a>
<a class="sourceLine" id="cb40-11" title="11">                <span class="cf">if</span> s[i] <span class="op">!=</span> s[<span class="op">-</span>(i <span class="op">+</span> <span class="dv">1</span>)]:</a>
<a class="sourceLine" id="cb40-12" title="12">                    <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb40-13" title="13">            <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb40-14" title="14"></a>
<a class="sourceLine" id="cb40-15" title="15">        <span class="kw">def</span> partitionRec(curr, s, i):</a>
<a class="sourceLine" id="cb40-16" title="16">            <span class="cf">if</span> i <span class="op">==</span> <span class="bu">len</span>(s):</a>
<a class="sourceLine" id="cb40-17" title="17">                result.append(curr)</a>
<a class="sourceLine" id="cb40-18" title="18">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb40-19" title="19">                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, <span class="bu">len</span>(s)):</a>
<a class="sourceLine" id="cb40-20" title="20">                    <span class="cf">if</span> valid(s[i : j <span class="op">+</span> <span class="dv">1</span>]):</a>
<a class="sourceLine" id="cb40-21" title="21">                        partitionRec(curr <span class="op">+</span> [s[i : j <span class="op">+</span> <span class="dv">1</span>]], s, j <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb40-22" title="22"></a>
<a class="sourceLine" id="cb40-23" title="23">        partitionRec([], s, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb40-24" title="24">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <div class="sourceCode" id="cb41">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb41-1" title="1"><span class="co">## Given a string s, partition s such that every substring of the partition is a palindrome.</span></a>
<a class="sourceLine" id="cb41-2" title="2"></a>
<a class="sourceLine" id="cb41-3" title="3">    Return the minimum cuts needed <span class="cf">for</span> a palindrome partitioning of s.</a>
<a class="sourceLine" id="cb41-4" title="4"></a>
<a class="sourceLine" id="cb41-5" title="5">    Example:</a>
<a class="sourceLine" id="cb41-6" title="6"></a>
<a class="sourceLine" id="cb41-7" title="7">    Input: <span class="st">&quot;aab&quot;</span></a>
<a class="sourceLine" id="cb41-8" title="8">    Output: <span class="dv">1</span></a>
<a class="sourceLine" id="cb41-9" title="9">    Explanation: The palindrome partitioning [<span class="st">&quot;aa&quot;</span>,<span class="st">&quot;b&quot;</span>] could be produced using <span class="dv">1</span> cut.</a>
<a class="sourceLine" id="cb41-10" title="10"></a>
<a class="sourceLine" id="cb41-11" title="11"></a>
<a class="sourceLine" id="cb41-12" title="12"></a>
<a class="sourceLine" id="cb41-13" title="13"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> minCut(<span class="va">self</span>, s):  :<span class="bu">type</span> s: <span class="bu">str</span> :rtype: <span class="bu">int</span>  <span class="cf">if</span> <span class="kw">not</span> s: <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb41-14" title="14"></a>
<a class="sourceLine" id="cb41-15" title="15">        P <span class="op">=</span> [[<span class="va">False</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s))] <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s))]</a>
<a class="sourceLine" id="cb41-16" title="16">        cuts <span class="op">=</span> [<span class="dv">0</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s))]</a>
<a class="sourceLine" id="cb41-17" title="17"></a>
<a class="sourceLine" id="cb41-18" title="18">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</a>
<a class="sourceLine" id="cb41-19" title="19">            P[index][index] <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb41-20" title="20"></a>
<a class="sourceLine" id="cb41-21" title="21">        <span class="cf">for</span> length <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb41-22" title="22">            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s) <span class="op">-</span> length <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb41-23" title="23">                j <span class="op">=</span> i <span class="op">+</span> length <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb41-24" title="24"></a>
<a class="sourceLine" id="cb41-25" title="25">                <span class="cf">if</span> length <span class="op">==</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb41-26" title="26">                    P[i][j] <span class="op">=</span> s[i] <span class="op">==</span> s[j]</a>
<a class="sourceLine" id="cb41-27" title="27">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb41-28" title="28">                    P[i][j] <span class="op">=</span> (s[i] <span class="op">==</span> s[j]) <span class="kw">and</span> P[i <span class="op">+</span> <span class="dv">1</span>][j <span class="op">-</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb41-29" title="29"></a>
<a class="sourceLine" id="cb41-30" title="30">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</a>
<a class="sourceLine" id="cb41-31" title="31">            <span class="cf">if</span> P[<span class="dv">0</span>][index]:</a>
<a class="sourceLine" id="cb41-32" title="32">                cuts[index] <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb41-33" title="33">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb41-34" title="34">                cuts[index] <span class="op">=</span> <span class="bu">float</span>(<span class="st">&quot;inf&quot;</span>)</a>
<a class="sourceLine" id="cb41-35" title="35">                <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(index):</a>
<a class="sourceLine" id="cb41-36" title="36">                    <span class="cf">if</span> P[j <span class="op">+</span> <span class="dv">1</span>][index] <span class="kw">and</span> (cuts[index] <span class="op">&gt;</span> <span class="dv">1</span> <span class="op">+</span> cuts[j]):</a>
<a class="sourceLine" id="cb41-37" title="37">                        cuts[index] <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span> cuts[j]</a>
<a class="sourceLine" id="cb41-38" title="38"></a>
<a class="sourceLine" id="cb41-39" title="39">        <span class="cf">return</span> cuts[<span class="bu">len</span>(s) <span class="op">-</span> <span class="dv">1</span>]</a>
<a class="sourceLine" id="cb41-40" title="40"></a>
<a class="sourceLine" id="cb41-41" title="41"><span class="co">### Time: O(N^2)</span></a>
<a class="sourceLine" id="cb41-42" title="42"></a>
<a class="sourceLine" id="cb41-43" title="43"><span class="co">### Space: O(N^2)</span></a></code></pre>
    </div>
    <div class="sourceCode" id="cb42">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb42-1" title="1"> There are N gas stations along a circular route, where the amount of gas at station i <span class="kw">is</span> gas[i].</a>
<a class="sourceLine" id="cb42-2" title="2"></a>
<a class="sourceLine" id="cb42-3" title="3">    You have a car <span class="cf">with</span> an unlimited gas tank <span class="kw">and</span> it costs cost[i] of gas to travel <span class="im">from</span> station i to its <span class="bu">next</span> station (i<span class="op">+</span><span class="dv">1</span>). You begin the journey <span class="cf">with</span> an empty tank at one of the gas stations.</a>
<a class="sourceLine" id="cb42-4" title="4"></a>
<a class="sourceLine" id="cb42-5" title="5">    Return the starting gas station<span class="st">&#39;s index if you can travel around the circuit once in the clockwise direction, otherwise return -1.</span></a>
<a class="sourceLine" id="cb42-6" title="6"></a>
<a class="sourceLine" id="cb42-7" title="7"></a>
<a class="sourceLine" id="cb42-8" title="8"></a>
<a class="sourceLine" id="cb42-9" title="9"><span class="st">class Solution(object): def canCompleteCircuit(self, gas, cost):  :type gas: List[int] :type cost: List[int] :rtype: int  start, curr_sum, total_sum = 0, 0, 0 for index in range(len(gas)): diff = gas[index] - cost[index] total_sum += diff curr_sum += diff</span></a>
<a class="sourceLine" id="cb42-10" title="10"></a>
<a class="sourceLine" id="cb42-11" title="11"><span class="st">            if curr_sum &lt; 0:</span></a>
<a class="sourceLine" id="cb42-12" title="12"><span class="st">                start = index + 1</span></a>
<a class="sourceLine" id="cb42-13" title="13"><span class="st">                curr_sum = 0</span></a>
<a class="sourceLine" id="cb42-14" title="14"></a>
<a class="sourceLine" id="cb42-15" title="15"><span class="st">        if total_sum &gt;= 0:</span></a>
<a class="sourceLine" id="cb42-16" title="16"><span class="st">            return start</span></a>
<a class="sourceLine" id="cb42-17" title="17"><span class="st">        return -1</span></a></code></pre>
    </div>
    <div class="sourceCode" id="cb43">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb43-1" title="1"><span class="co">## Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.</span></a>
<a class="sourceLine" id="cb43-2" title="2"></a>
<a class="sourceLine" id="cb43-3" title="3">    Note:</a>
<a class="sourceLine" id="cb43-4" title="4"></a>
<a class="sourceLine" id="cb43-5" title="5">    The same word <span class="kw">in</span> the dictionary may be reused multiple times <span class="kw">in</span> the segmentation.</a>
<a class="sourceLine" id="cb43-6" title="6">    You may assume the dictionary does <span class="kw">not</span> contain duplicate words.</a>
<a class="sourceLine" id="cb43-7" title="7">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb43-8" title="8"></a>
<a class="sourceLine" id="cb43-9" title="9">    Input: s <span class="op">=</span> <span class="st">&quot;leetcode&quot;</span>, wordDict <span class="op">=</span> [<span class="st">&quot;leet&quot;</span>, <span class="st">&quot;code&quot;</span>]</a>
<a class="sourceLine" id="cb43-10" title="10">    Output: true</a>
<a class="sourceLine" id="cb43-11" title="11">    Explanation: Return true because <span class="st">&quot;leetcode&quot;</span> can be segmented <span class="im">as</span> <span class="st">&quot;leet code&quot;</span>.</a>
<a class="sourceLine" id="cb43-12" title="12"></a>
<a class="sourceLine" id="cb43-13" title="13"></a>
<a class="sourceLine" id="cb43-14" title="14"></a>
<a class="sourceLine" id="cb43-15" title="15"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> wordBreak(<span class="va">self</span>, s, wordDict):  :<span class="bu">type</span> s: <span class="bu">str</span> :<span class="bu">type</span> wordDict: List[<span class="bu">str</span>] :rtype: <span class="bu">bool</span>  dp <span class="op">=</span> [<span class="va">False</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>)] dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span> <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)): <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, <span class="dv">-1</span>, <span class="dv">-1</span>): <span class="cf">if</span> dp[j] <span class="kw">and</span> s[j : i <span class="op">+</span> <span class="dv">1</span>] <span class="kw">in</span> wordDict: dp[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span> <span class="cf">break</span> <span class="cf">return</span> dp[<span class="bu">len</span>(s)]</a>
<a class="sourceLine" id="cb43-16" title="16"></a>
<a class="sourceLine" id="cb43-17" title="17"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> wordBreak(<span class="va">self</span>, s, wordDict):  :<span class="bu">type</span> s: <span class="bu">str</span> :<span class="bu">type</span> wordDict: List[<span class="bu">str</span>] :rtype: List[<span class="bu">str</span>]  <span class="va">self</span>.result <span class="op">=</span> [] <span class="va">self</span>.dfs(s, wordDict, <span class="st">&quot;&quot;</span>) <span class="cf">return</span> <span class="va">self</span>.result</a>
<a class="sourceLine" id="cb43-18" title="18"></a>
<a class="sourceLine" id="cb43-19" title="19">    <span class="kw">def</span> dfs(<span class="va">self</span>, s, wordDict, currStr):</a>
<a class="sourceLine" id="cb43-20" title="20">        <span class="cf">if</span> <span class="va">self</span>.check(s, wordDict):</a>
<a class="sourceLine" id="cb43-21" title="21">            <span class="cf">if</span> <span class="bu">len</span>(s) <span class="op">==</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb43-22" title="22">                <span class="va">self</span>.result.append(currStr[<span class="dv">1</span>:])</a>
<a class="sourceLine" id="cb43-23" title="23">            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb43-24" title="24">                <span class="cf">if</span> s[:i] <span class="kw">in</span> wordDict:</a>
<a class="sourceLine" id="cb43-25" title="25">                    <span class="va">self</span>.dfs(s[i:], wordDict, currStr <span class="op">+</span> <span class="st">&quot; &quot;</span> <span class="op">+</span> s[:i])</a>
<a class="sourceLine" id="cb43-26" title="26"></a>
<a class="sourceLine" id="cb43-27" title="27">    <span class="kw">def</span> check(<span class="va">self</span>, s, wordDict):</a>
<a class="sourceLine" id="cb43-28" title="28">        dp <span class="op">=</span> [<span class="va">False</span> <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s) <span class="op">+</span> <span class="dv">1</span>)]</a>
<a class="sourceLine" id="cb43-29" title="29">        dp[<span class="dv">0</span>] <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb43-30" title="30"></a>
<a class="sourceLine" id="cb43-31" title="31">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(s)):</a>
<a class="sourceLine" id="cb43-32" title="32">            <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(i, <span class="dv">-1</span>, <span class="dv">-1</span>):</a>
<a class="sourceLine" id="cb43-33" title="33">                <span class="cf">if</span> dp[j] <span class="kw">and</span> s[j : i <span class="op">+</span> <span class="dv">1</span>] <span class="kw">in</span> wordDict:</a>
<a class="sourceLine" id="cb43-34" title="34">                    dp[i <span class="op">+</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb43-35" title="35">                    <span class="cf">break</span></a>
<a class="sourceLine" id="cb43-36" title="36"></a>
<a class="sourceLine" id="cb43-37" title="37">        <span class="cf">return</span> dp[<span class="bu">len</span>(s)]</a></code></pre>
    </div>
    <div class="sourceCode" id="cb44">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb44-1" title="1"><span class="co">## Given a linked list, determine if it has a cycle in it.</span></a>
<a class="sourceLine" id="cb44-2" title="2"></a>
<a class="sourceLine" id="cb44-3" title="3">    Follow up:</a>
<a class="sourceLine" id="cb44-4" title="4">    Can you solve it without using extra space?</a>
<a class="sourceLine" id="cb44-5" title="5"></a>
<a class="sourceLine" id="cb44-6" title="6"></a>
<a class="sourceLine" id="cb44-7" title="7"></a>
<a class="sourceLine" id="cb44-8" title="8"><span class="op">---</span></a>
<a class="sourceLine" id="cb44-9" title="9"></a>
<a class="sourceLine" id="cb44-10" title="10"><span class="co">### Definition for singly-linked list.</span></a>
<a class="sourceLine" id="cb44-11" title="11"></a>
<a class="sourceLine" id="cb44-12" title="12"><span class="co">### class ListNode(object):</span></a>
<a class="sourceLine" id="cb44-13" title="13"></a>
<a class="sourceLine" id="cb44-14" title="14"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb44-15" title="15"></a>
<a class="sourceLine" id="cb44-16" title="16"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb44-17" title="17"></a>
<a class="sourceLine" id="cb44-18" title="18"><span class="co">### self.next = None</span></a></code></pre>
    </div>
    <div class="sourceCode" id="cb45">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb45-1" title="1"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> hasCycle(<span class="va">self</span>, head):  :<span class="bu">type</span> head: ListNode :rtype: <span class="bu">bool</span></a>
<a class="sourceLine" id="cb45-2" title="2"></a>
<a class="sourceLine" id="cb45-3" title="3">        <span class="cf">if</span> <span class="kw">not</span> head:</a>
<a class="sourceLine" id="cb45-4" title="4">            <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb45-5" title="5"></a>
<a class="sourceLine" id="cb45-6" title="6">        slow, fast <span class="op">=</span> head, head</a>
<a class="sourceLine" id="cb45-7" title="7">        <span class="cf">while</span> fast <span class="kw">and</span> fast.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb45-8" title="8">            slow <span class="op">=</span> slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb45-9" title="9">            fast <span class="op">=</span> fast.<span class="bu">next</span>.<span class="bu">next</span></a>
<a class="sourceLine" id="cb45-10" title="10">            <span class="cf">if</span> slow <span class="op">==</span> fast:</a>
<a class="sourceLine" id="cb45-11" title="11">                <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb45-12" title="12">        <span class="cf">return</span> <span class="va">False</span></a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb46">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb46-1" title="1"></a>
<a class="sourceLine" id="cb46-2" title="2"><span class="co">## Given a linked list, return the node where the cycle begins. If there is no cycle, return null.</span></a>
<a class="sourceLine" id="cb46-3" title="3"></a>
<a class="sourceLine" id="cb46-4" title="4">    Note: Do <span class="kw">not</span> modify the linked <span class="bu">list</span>.</a>
<a class="sourceLine" id="cb46-5" title="5"></a>
<a class="sourceLine" id="cb46-6" title="6">    Follow up:</a>
<a class="sourceLine" id="cb46-7" title="7">    Can you solve it without using extra space?</a>
<a class="sourceLine" id="cb46-8" title="8"></a>
<a class="sourceLine" id="cb46-9" title="9"> <span class="co"># Definition for singly-linked list. # class ListNode(object): # def **init**(self, x): # self.val = x # self.next = None</span></a>
<a class="sourceLine" id="cb46-10" title="10"></a>
<a class="sourceLine" id="cb46-11" title="11"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> detectCycle(<span class="va">self</span>, head):  :<span class="bu">type</span> head: ListNode :rtype: ListNode  <span class="cf">if</span> <span class="kw">not</span> head: <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb46-12" title="12"></a>
<a class="sourceLine" id="cb46-13" title="13">        slow, fast <span class="op">=</span> head, head.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-14" title="14"></a>
<a class="sourceLine" id="cb46-15" title="15">        <span class="cf">while</span> fast <span class="kw">and</span> fast.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb46-16" title="16">            slow <span class="op">=</span> slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-17" title="17">            fast <span class="op">=</span> fast.<span class="bu">next</span>.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-18" title="18">            <span class="cf">if</span> slow <span class="op">==</span> fast:</a>
<a class="sourceLine" id="cb46-19" title="19">                <span class="cf">break</span></a>
<a class="sourceLine" id="cb46-20" title="20"></a>
<a class="sourceLine" id="cb46-21" title="21">        <span class="cf">if</span> slow <span class="op">==</span> fast:</a>
<a class="sourceLine" id="cb46-22" title="22">            slow <span class="op">=</span> head</a>
<a class="sourceLine" id="cb46-23" title="23">            <span class="cf">while</span> slow <span class="op">!=</span> fast:</a>
<a class="sourceLine" id="cb46-24" title="24">                slow <span class="op">=</span> slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-25" title="25">                fast <span class="op">=</span> fast.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-26" title="26">            <span class="cf">return</span> slow</a>
<a class="sourceLine" id="cb46-27" title="27">        <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb46-28" title="28"></a>
<a class="sourceLine" id="cb46-29" title="29"><span class="op">---</span></a>
<a class="sourceLine" id="cb46-30" title="30"></a>
<a class="sourceLine" id="cb46-31" title="31"><span class="co">### Definition for singly-linked list.</span></a>
<a class="sourceLine" id="cb46-32" title="32"></a>
<a class="sourceLine" id="cb46-33" title="33"><span class="co">### class ListNode(object):</span></a>
<a class="sourceLine" id="cb46-34" title="34"></a>
<a class="sourceLine" id="cb46-35" title="35"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb46-36" title="36"></a>
<a class="sourceLine" id="cb46-37" title="37"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb46-38" title="38"></a>
<a class="sourceLine" id="cb46-39" title="39"><span class="co">### self.next = None</span></a>
<a class="sourceLine" id="cb46-40" title="40"></a>
<a class="sourceLine" id="cb46-41" title="41"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> reorderList(<span class="va">self</span>, head):  :<span class="bu">type</span> head: ListNode :rtype: void Do <span class="kw">not</span> <span class="cf">return</span> anything, modify head <span class="kw">in</span><span class="op">-</span>place instead.  <span class="cf">if</span> <span class="kw">not</span> head: <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb46-42" title="42"></a>
<a class="sourceLine" id="cb46-43" title="43">        slow, fast <span class="op">=</span> head, head.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-44" title="44"></a>
<a class="sourceLine" id="cb46-45" title="45">        <span class="cf">while</span> fast <span class="kw">and</span> fast.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb46-46" title="46">            slow <span class="op">=</span> slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-47" title="47">            fast <span class="op">=</span> fast.<span class="bu">next</span>.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-48" title="48"></a>
<a class="sourceLine" id="cb46-49" title="49">        head1, head2 <span class="op">=</span> head, slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-50" title="50">        slow.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb46-51" title="51">        prev <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb46-52" title="52">        curr <span class="op">=</span> head2</a>
<a class="sourceLine" id="cb46-53" title="53">        <span class="cf">while</span> curr:</a>
<a class="sourceLine" id="cb46-54" title="54">            nex <span class="op">=</span> curr.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-55" title="55">            curr.<span class="bu">next</span> <span class="op">=</span> prev</a>
<a class="sourceLine" id="cb46-56" title="56">            prev <span class="op">=</span> curr</a>
<a class="sourceLine" id="cb46-57" title="57">            curr <span class="op">=</span> nex</a>
<a class="sourceLine" id="cb46-58" title="58">        head2 <span class="op">=</span> prev</a>
<a class="sourceLine" id="cb46-59" title="59"></a>
<a class="sourceLine" id="cb46-60" title="60">        <span class="cf">while</span> head2:</a>
<a class="sourceLine" id="cb46-61" title="61">            n1 <span class="op">=</span> head1.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-62" title="62">            n2 <span class="op">=</span> head2.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-63" title="63">            head1.<span class="bu">next</span> <span class="op">=</span> head2</a>
<a class="sourceLine" id="cb46-64" title="64">            head1.<span class="bu">next</span>.<span class="bu">next</span> <span class="op">=</span> n1</a>
<a class="sourceLine" id="cb46-65" title="65">            head2 <span class="op">=</span> n2</a>
<a class="sourceLine" id="cb46-66" title="66">            head1 <span class="op">=</span> head1.<span class="bu">next</span>.<span class="bu">next</span></a>
<a class="sourceLine" id="cb46-67" title="67"></a>
<a class="sourceLine" id="cb46-68" title="68">        head <span class="op">=</span> head1</a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb47">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb47-1" title="1"></a>
<a class="sourceLine" id="cb47-2" title="2"><span class="co">## Given a binary tree, return the preorder traversal of its nodes’ values.</span></a>
<a class="sourceLine" id="cb47-3" title="3"></a>
<a class="sourceLine" id="cb47-4" title="4">    Example:</a>
<a class="sourceLine" id="cb47-5" title="5"></a>
<a class="sourceLine" id="cb47-6" title="6">    Input: [<span class="dv">1</span>,null,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb47-7" title="7">       <span class="dv">1</span></a>
<a class="sourceLine" id="cb47-8" title="8">        <span class="op">\</span></a>
<a class="sourceLine" id="cb47-9" title="9">         <span class="dv">2</span></a>
<a class="sourceLine" id="cb47-10" title="10">        <span class="op">/</span></a>
<a class="sourceLine" id="cb47-11" title="11">       <span class="dv">3</span></a>
<a class="sourceLine" id="cb47-12" title="12"></a>
<a class="sourceLine" id="cb47-13" title="13">    Output: [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb47-14" title="14">    Follow up: Recursive solution <span class="kw">is</span> trivial, could you do it iteratively?</a>
<a class="sourceLine" id="cb47-15" title="15"></a>
<a class="sourceLine" id="cb47-16" title="16"></a>
<a class="sourceLine" id="cb47-17" title="17"></a>
<a class="sourceLine" id="cb47-18" title="18"><span class="op">---</span></a>
<a class="sourceLine" id="cb47-19" title="19"></a>
<a class="sourceLine" id="cb47-20" title="20"><span class="co">### Definition for a binary tree node.</span></a>
<a class="sourceLine" id="cb47-21" title="21"></a>
<a class="sourceLine" id="cb47-22" title="22"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb47-23" title="23"></a>
<a class="sourceLine" id="cb47-24" title="24"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb47-25" title="25"></a>
<a class="sourceLine" id="cb47-26" title="26"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb47-27" title="27"></a>
<a class="sourceLine" id="cb47-28" title="28"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb47-29" title="29"></a>
<a class="sourceLine" id="cb47-30" title="30"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb47-31" title="31"></a>
<a class="sourceLine" id="cb47-32" title="32"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> preorderTraversal(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: List[<span class="bu">int</span>]  <span class="cf">if</span> <span class="kw">not</span> root: <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb47-33" title="33"></a>
<a class="sourceLine" id="cb47-34" title="34">        stack, result <span class="op">=</span> [root], []</a>
<a class="sourceLine" id="cb47-35" title="35">        <span class="cf">while</span> stack:</a>
<a class="sourceLine" id="cb47-36" title="36">            element <span class="op">=</span> stack.pop()</a>
<a class="sourceLine" id="cb47-37" title="37">            result.append(element.val)</a>
<a class="sourceLine" id="cb47-38" title="38"></a>
<a class="sourceLine" id="cb47-39" title="39">            <span class="cf">if</span> element.right:</a>
<a class="sourceLine" id="cb47-40" title="40">                stack.append(element.right)</a>
<a class="sourceLine" id="cb47-41" title="41">            <span class="cf">if</span> element.left:</a>
<a class="sourceLine" id="cb47-42" title="42">                stack.append(element.left)</a>
<a class="sourceLine" id="cb47-43" title="43"></a>
<a class="sourceLine" id="cb47-44" title="44">        <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb47-45" title="45"></a>
<a class="sourceLine" id="cb47-46" title="46"><span class="op">---</span></a>
<a class="sourceLine" id="cb47-47" title="47"></a>
<a class="sourceLine" id="cb47-48" title="48"><span class="co">### Definition for a binary tree node.</span></a>
<a class="sourceLine" id="cb47-49" title="49"></a>
<a class="sourceLine" id="cb47-50" title="50"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb47-51" title="51"></a>
<a class="sourceLine" id="cb47-52" title="52"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb47-53" title="53"></a>
<a class="sourceLine" id="cb47-54" title="54"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb47-55" title="55"></a>
<a class="sourceLine" id="cb47-56" title="56"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb47-57" title="57"></a>
<a class="sourceLine" id="cb47-58" title="58"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb47-59" title="59"></a>
<a class="sourceLine" id="cb47-60" title="60"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> preorderTraversal(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: List[<span class="bu">int</span>]  result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb47-61" title="61"></a>
<a class="sourceLine" id="cb47-62" title="62">        <span class="kw">def</span> recursive(root, result):</a>
<a class="sourceLine" id="cb47-63" title="63">            <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb47-64" title="64">                <span class="cf">return</span></a>
<a class="sourceLine" id="cb47-65" title="65">            result.append(root.val)</a>
<a class="sourceLine" id="cb47-66" title="66">            recursive(root.left, result)</a>
<a class="sourceLine" id="cb47-67" title="67">            recursive(root.right, result)</a>
<a class="sourceLine" id="cb47-68" title="68"></a>
<a class="sourceLine" id="cb47-69" title="69">        recursive(root, result)</a>
<a class="sourceLine" id="cb47-70" title="70">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb48">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb48-1" title="1"></a>
<a class="sourceLine" id="cb48-2" title="2"><span class="co">## Given a binary tree, return the postorder traversal of its nodes’ values.</span></a>
<a class="sourceLine" id="cb48-3" title="3"></a>
<a class="sourceLine" id="cb48-4" title="4">    Example:</a>
<a class="sourceLine" id="cb48-5" title="5"></a>
<a class="sourceLine" id="cb48-6" title="6">    Input: [<span class="dv">1</span>,null,<span class="dv">2</span>,<span class="dv">3</span>]</a>
<a class="sourceLine" id="cb48-7" title="7">       <span class="dv">1</span></a>
<a class="sourceLine" id="cb48-8" title="8">        <span class="op">\</span></a>
<a class="sourceLine" id="cb48-9" title="9">         <span class="dv">2</span></a>
<a class="sourceLine" id="cb48-10" title="10">        <span class="op">/</span></a>
<a class="sourceLine" id="cb48-11" title="11">       <span class="dv">3</span></a>
<a class="sourceLine" id="cb48-12" title="12"></a>
<a class="sourceLine" id="cb48-13" title="13">    Output: [<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb48-14" title="14">    Follow up: Recursive solution <span class="kw">is</span> trivial, could you do it iteratively?</a>
<a class="sourceLine" id="cb48-15" title="15"></a>
<a class="sourceLine" id="cb48-16" title="16"></a>
<a class="sourceLine" id="cb48-17" title="17"></a>
<a class="sourceLine" id="cb48-18" title="18"><span class="op">---</span></a>
<a class="sourceLine" id="cb48-19" title="19"></a>
<a class="sourceLine" id="cb48-20" title="20"><span class="co">### Definition for a binary tree node.</span></a>
<a class="sourceLine" id="cb48-21" title="21"></a>
<a class="sourceLine" id="cb48-22" title="22"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb48-23" title="23"></a>
<a class="sourceLine" id="cb48-24" title="24"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb48-25" title="25"></a>
<a class="sourceLine" id="cb48-26" title="26"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb48-27" title="27"></a>
<a class="sourceLine" id="cb48-28" title="28"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb48-29" title="29"></a>
<a class="sourceLine" id="cb48-30" title="30"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb48-31" title="31"></a>
<a class="sourceLine" id="cb48-32" title="32"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> postorderTraversal(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: List[<span class="bu">int</span>]</a>
<a class="sourceLine" id="cb48-33" title="33"></a>
<a class="sourceLine" id="cb48-34" title="34">        result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb48-35" title="35"></a>
<a class="sourceLine" id="cb48-36" title="36">        <span class="kw">def</span> recursive(root, result):</a>
<a class="sourceLine" id="cb48-37" title="37">            <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb48-38" title="38">                <span class="cf">return</span></a>
<a class="sourceLine" id="cb48-39" title="39">            recursive(root.left, result)</a>
<a class="sourceLine" id="cb48-40" title="40">            recursive(root.right, result)</a>
<a class="sourceLine" id="cb48-41" title="41">            result.append(root.val)</a>
<a class="sourceLine" id="cb48-42" title="42"></a>
<a class="sourceLine" id="cb48-43" title="43">        recursive(root, result)</a>
<a class="sourceLine" id="cb48-44" title="44">        <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb48-45" title="45"></a>
<a class="sourceLine" id="cb48-46" title="46"><span class="op">---</span></a>
<a class="sourceLine" id="cb48-47" title="47"></a>
<a class="sourceLine" id="cb48-48" title="48"><span class="co">### Definition for a binary tree node.</span></a>
<a class="sourceLine" id="cb48-49" title="49"></a>
<a class="sourceLine" id="cb48-50" title="50"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb48-51" title="51"></a>
<a class="sourceLine" id="cb48-52" title="52"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb48-53" title="53"></a>
<a class="sourceLine" id="cb48-54" title="54"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb48-55" title="55"></a>
<a class="sourceLine" id="cb48-56" title="56"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb48-57" title="57"></a>
<a class="sourceLine" id="cb48-58" title="58"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb48-59" title="59"></a>
<a class="sourceLine" id="cb48-60" title="60"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> postorderTraversal(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: List[<span class="bu">int</span>]</a>
<a class="sourceLine" id="cb48-61" title="61"></a>
<a class="sourceLine" id="cb48-62" title="62">        <span class="cf">if</span> <span class="kw">not</span> root:</a>
<a class="sourceLine" id="cb48-63" title="63">            <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb48-64" title="64"></a>
<a class="sourceLine" id="cb48-65" title="65">        stack, result <span class="op">=</span> [], []</a>
<a class="sourceLine" id="cb48-66" title="66"></a>
<a class="sourceLine" id="cb48-67" title="67">        <span class="cf">while</span> <span class="va">True</span>:</a>
<a class="sourceLine" id="cb48-68" title="68">            <span class="cf">while</span> root:</a>
<a class="sourceLine" id="cb48-69" title="69">                <span class="cf">if</span> root.right:</a>
<a class="sourceLine" id="cb48-70" title="70">                    stack.append(root.right)</a>
<a class="sourceLine" id="cb48-71" title="71">                stack.append(root)</a>
<a class="sourceLine" id="cb48-72" title="72">                root <span class="op">=</span> root.left</a>
<a class="sourceLine" id="cb48-73" title="73"></a>
<a class="sourceLine" id="cb48-74" title="74">            root <span class="op">=</span> stack.pop()</a>
<a class="sourceLine" id="cb48-75" title="75"></a>
<a class="sourceLine" id="cb48-76" title="76">            <span class="cf">if</span> root.right <span class="kw">and</span> stack <span class="kw">and</span> stack[<span class="op">-</span><span class="dv">1</span>] <span class="op">==</span> root.right:</a>
<a class="sourceLine" id="cb48-77" title="77">                stack.pop()</a>
<a class="sourceLine" id="cb48-78" title="78">                stack.append(root)</a>
<a class="sourceLine" id="cb48-79" title="79">                root <span class="op">=</span> root.right</a>
<a class="sourceLine" id="cb48-80" title="80">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb48-81" title="81">                result.append(root.val)</a>
<a class="sourceLine" id="cb48-82" title="82">                root <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb48-83" title="83"></a>
<a class="sourceLine" id="cb48-84" title="84">            <span class="cf">if</span> <span class="bu">len</span>(stack) <span class="op">&lt;=</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb48-85" title="85">                <span class="cf">break</span></a>
<a class="sourceLine" id="cb48-86" title="86"></a>
<a class="sourceLine" id="cb48-87" title="87">        <span class="cf">return</span> result</a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb49">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb49-1" title="1"> Design <span class="kw">and</span> implement a data structure <span class="cf">for</span> Least Recently Used (LRU) cache. It should support the following operations: get <span class="kw">and</span> put.</a>
<a class="sourceLine" id="cb49-2" title="2"></a>
<a class="sourceLine" id="cb49-3" title="3">    get(key) <span class="op">-</span> Get the value (will always be positive) of the key <span class="cf">if</span> the key exists <span class="kw">in</span> the cache, otherwise <span class="cf">return</span> <span class="fl">-1.</span></a>
<a class="sourceLine" id="cb49-4" title="4">    put(key, value) <span class="op">-</span> Set <span class="kw">or</span> insert the value <span class="cf">if</span> the key <span class="kw">is</span> <span class="kw">not</span> already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</a>
<a class="sourceLine" id="cb49-5" title="5"></a>
<a class="sourceLine" id="cb49-6" title="6">    Follow up:</a>
<a class="sourceLine" id="cb49-7" title="7">    Could you do both operations <span class="kw">in</span> O(<span class="dv">1</span>) time complexity?</a>
<a class="sourceLine" id="cb49-8" title="8"></a>
<a class="sourceLine" id="cb49-9" title="9">    Example:</a>
<a class="sourceLine" id="cb49-10" title="10"></a>
<a class="sourceLine" id="cb49-11" title="11">    LRUCache cache <span class="op">=</span> new LRUCache( <span class="dv">2</span> <span class="op">/*</span> capacity <span class="op">*/</span> )<span class="op">;</span></a>
<a class="sourceLine" id="cb49-12" title="12"></a>
<a class="sourceLine" id="cb49-13" title="13">    cache.put(<span class="dv">1</span>, <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb49-14" title="14">    cache.put(<span class="dv">2</span>, <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb49-15" title="15">    cache.get(<span class="dv">1</span>)<span class="op">;</span>       <span class="op">//</span> returns <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-16" title="16">    cache.put(<span class="dv">3</span>, <span class="dv">3</span>)<span class="op">;</span>    <span class="op">//</span> evicts key <span class="dv">2</span></a>
<a class="sourceLine" id="cb49-17" title="17">    cache.get(<span class="dv">2</span>)<span class="op">;</span>       <span class="op">//</span> returns <span class="dv">-1</span> (<span class="kw">not</span> found)</a>
<a class="sourceLine" id="cb49-18" title="18">    cache.put(<span class="dv">4</span>, <span class="dv">4</span>)<span class="op">;</span>    <span class="op">//</span> evicts key <span class="dv">1</span></a>
<a class="sourceLine" id="cb49-19" title="19">    cache.get(<span class="dv">1</span>)<span class="op">;</span>       <span class="op">//</span> returns <span class="dv">-1</span> (<span class="kw">not</span> found)</a>
<a class="sourceLine" id="cb49-20" title="20">    cache.get(<span class="dv">3</span>)<span class="op">;</span>       <span class="op">//</span> returns <span class="dv">3</span></a>
<a class="sourceLine" id="cb49-21" title="21">    cache.get(<span class="dv">4</span>)<span class="op">;</span>       <span class="op">//</span> returns <span class="dv">4</span></a>
<a class="sourceLine" id="cb49-22" title="22"></a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb50">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb50-1" title="1"><span class="kw">class</span> Node(<span class="bu">object</span>): <span class="kw">def</span> <span class="op">**</span>init<span class="op">**</span>(<span class="va">self</span>, key, value): <span class="va">self</span>.key <span class="op">=</span> key <span class="va">self</span>.value <span class="op">=</span> value <span class="va">self</span>.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span> <span class="va">self</span>.prev <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb50-2" title="2"></a>
<a class="sourceLine" id="cb50-3" title="3"><span class="kw">class</span> LRUCache(<span class="bu">object</span>): <span class="kw">def</span> <span class="op">**</span>init<span class="op">**</span>(<span class="va">self</span>, capacity):  :<span class="bu">type</span> capacity: <span class="bu">int</span>  <span class="va">self</span>.capacity <span class="op">=</span> capacity <span class="va">self</span>.mapping <span class="op">=</span> <span class="bu">dict</span>() <span class="va">self</span>.head <span class="op">=</span> Node(<span class="dv">0</span>, <span class="dv">0</span>) <span class="va">self</span>.tail <span class="op">=</span> Node(<span class="dv">0</span>, <span class="dv">0</span>) <span class="va">self</span>.head.<span class="bu">next</span> <span class="op">=</span> <span class="va">self</span>.tail <span class="va">self</span>.tail.prev <span class="op">=</span> <span class="va">self</span>.head</a>
<a class="sourceLine" id="cb50-4" title="4"></a>
<a class="sourceLine" id="cb50-5" title="5">    <span class="kw">def</span> get(<span class="va">self</span>, key):</a>
<a class="sourceLine" id="cb50-6" title="6"></a>
<a class="sourceLine" id="cb50-7" title="7">        :<span class="bu">type</span> key: <span class="bu">int</span></a>
<a class="sourceLine" id="cb50-8" title="8">        :rtype: <span class="bu">int</span></a>
<a class="sourceLine" id="cb50-9" title="9"></a>
<a class="sourceLine" id="cb50-10" title="10">        <span class="cf">if</span> key <span class="kw">in</span> <span class="va">self</span>.mapping:</a>
<a class="sourceLine" id="cb50-11" title="11">            node <span class="op">=</span> <span class="va">self</span>.mapping[key]</a>
<a class="sourceLine" id="cb50-12" title="12">            <span class="va">self</span>.remove(node)</a>
<a class="sourceLine" id="cb50-13" title="13">            <span class="va">self</span>.add(node)</a>
<a class="sourceLine" id="cb50-14" title="14">            <span class="cf">return</span> node.value</a>
<a class="sourceLine" id="cb50-15" title="15">        <span class="cf">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb50-16" title="16"></a>
<a class="sourceLine" id="cb50-17" title="17">    <span class="kw">def</span> put(<span class="va">self</span>, key, value):</a>
<a class="sourceLine" id="cb50-18" title="18"></a>
<a class="sourceLine" id="cb50-19" title="19">        :<span class="bu">type</span> key: <span class="bu">int</span></a>
<a class="sourceLine" id="cb50-20" title="20">        :<span class="bu">type</span> value: <span class="bu">int</span></a>
<a class="sourceLine" id="cb50-21" title="21">        :rtype: void</a>
<a class="sourceLine" id="cb50-22" title="22"></a>
<a class="sourceLine" id="cb50-23" title="23"></a>
<a class="sourceLine" id="cb50-24" title="24">        <span class="cf">if</span> key <span class="kw">in</span> <span class="va">self</span>.mapping:</a>
<a class="sourceLine" id="cb50-25" title="25">            <span class="va">self</span>.remove(<span class="va">self</span>.mapping[key])</a>
<a class="sourceLine" id="cb50-26" title="26"></a>
<a class="sourceLine" id="cb50-27" title="27">        node <span class="op">=</span> Node(key, value)</a>
<a class="sourceLine" id="cb50-28" title="28">        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.mapping) <span class="op">&gt;=</span> <span class="va">self</span>.capacity:</a>
<a class="sourceLine" id="cb50-29" title="29">            next_head <span class="op">=</span> <span class="va">self</span>.head.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-30" title="30">            <span class="va">self</span>.remove(next_head)</a>
<a class="sourceLine" id="cb50-31" title="31">            <span class="kw">del</span> <span class="va">self</span>.mapping[next_head.key]</a>
<a class="sourceLine" id="cb50-32" title="32"></a>
<a class="sourceLine" id="cb50-33" title="33">        <span class="va">self</span>.add(node)</a>
<a class="sourceLine" id="cb50-34" title="34">        <span class="va">self</span>.mapping[key] <span class="op">=</span> node</a>
<a class="sourceLine" id="cb50-35" title="35"></a>
<a class="sourceLine" id="cb50-36" title="36">    <span class="kw">def</span> add(<span class="va">self</span>, node):</a>
<a class="sourceLine" id="cb50-37" title="37">        tail <span class="op">=</span> <span class="va">self</span>.tail.prev</a>
<a class="sourceLine" id="cb50-38" title="38">        tail.<span class="bu">next</span> <span class="op">=</span> node</a>
<a class="sourceLine" id="cb50-39" title="39">        <span class="va">self</span>.tail.prev <span class="op">=</span> node</a>
<a class="sourceLine" id="cb50-40" title="40">        node.prev <span class="op">=</span> tail</a>
<a class="sourceLine" id="cb50-41" title="41">        node.<span class="bu">next</span> <span class="op">=</span> <span class="va">self</span>.tail</a>
<a class="sourceLine" id="cb50-42" title="42"></a>
<a class="sourceLine" id="cb50-43" title="43">    <span class="kw">def</span> remove(<span class="va">self</span>, node):</a>
<a class="sourceLine" id="cb50-44" title="44">        prev_node <span class="op">=</span> node.prev</a>
<a class="sourceLine" id="cb50-45" title="45">        prev_node.<span class="bu">next</span> <span class="op">=</span> node.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-46" title="46">        node.<span class="bu">next</span>.prev <span class="op">=</span> prev_node</a>
<a class="sourceLine" id="cb50-47" title="47"></a>
<a class="sourceLine" id="cb50-48" title="48"><span class="co">### Your LRUCache object will be instantiated and called as such:</span></a>
<a class="sourceLine" id="cb50-49" title="49"></a>
<a class="sourceLine" id="cb50-50" title="50"><span class="co">### obj = LRUCache(capacity)</span></a>
<a class="sourceLine" id="cb50-51" title="51"></a>
<a class="sourceLine" id="cb50-52" title="52"><span class="co">### param_1 = obj.get(key)</span></a>
<a class="sourceLine" id="cb50-53" title="53"></a>
<a class="sourceLine" id="cb50-54" title="54"><span class="co">### obj.put(key,value)</span></a>
<a class="sourceLine" id="cb50-55" title="55"></a>
<a class="sourceLine" id="cb50-56" title="56"><span class="op">---</span></a>
<a class="sourceLine" id="cb50-57" title="57"></a>
<a class="sourceLine" id="cb50-58" title="58"><span class="co">### Definition for singly-linked list.</span></a>
<a class="sourceLine" id="cb50-59" title="59"></a>
<a class="sourceLine" id="cb50-60" title="60"><span class="co">### class ListNode(object):</span></a>
<a class="sourceLine" id="cb50-61" title="61"></a>
<a class="sourceLine" id="cb50-62" title="62"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb50-63" title="63"></a>
<a class="sourceLine" id="cb50-64" title="64"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb50-65" title="65"></a>
<a class="sourceLine" id="cb50-66" title="66"><span class="co">### self.next = None</span></a>
<a class="sourceLine" id="cb50-67" title="67"></a>
<a class="sourceLine" id="cb50-68" title="68"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> insertionSortList(<span class="va">self</span>, head):  :<span class="bu">type</span> head: ListNode :rtype: ListNode</a>
<a class="sourceLine" id="cb50-69" title="69"></a>
<a class="sourceLine" id="cb50-70" title="70">        <span class="cf">if</span> <span class="kw">not</span> head:</a>
<a class="sourceLine" id="cb50-71" title="71">            <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb50-72" title="72"></a>
<a class="sourceLine" id="cb50-73" title="73">        sortedList <span class="op">=</span> head</a>
<a class="sourceLine" id="cb50-74" title="74">        head <span class="op">=</span> head.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-75" title="75">        sortedList.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb50-76" title="76"></a>
<a class="sourceLine" id="cb50-77" title="77">        <span class="cf">while</span> head:</a>
<a class="sourceLine" id="cb50-78" title="78">            curr <span class="op">=</span> head</a>
<a class="sourceLine" id="cb50-79" title="79">            head <span class="op">=</span> head.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-80" title="80">            <span class="cf">if</span> curr.val <span class="op">&lt;=</span> sortedList.val:</a>
<a class="sourceLine" id="cb50-81" title="81">                curr.<span class="bu">next</span> <span class="op">=</span> sortedList</a>
<a class="sourceLine" id="cb50-82" title="82">                sortedList <span class="op">=</span> curr</a>
<a class="sourceLine" id="cb50-83" title="83">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb50-84" title="84">                temp <span class="op">=</span> sortedList</a>
<a class="sourceLine" id="cb50-85" title="85">                <span class="cf">while</span> temp.<span class="bu">next</span> <span class="kw">and</span> temp.<span class="bu">next</span>.val <span class="op">&lt;</span> curr.val:</a>
<a class="sourceLine" id="cb50-86" title="86">                    temp <span class="op">=</span> temp.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-87" title="87">                curr.<span class="bu">next</span> <span class="op">=</span> temp.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-88" title="88">                temp.<span class="bu">next</span> <span class="op">=</span> curr</a>
<a class="sourceLine" id="cb50-89" title="89">        <span class="cf">return</span> sortedList</a>
<a class="sourceLine" id="cb50-90" title="90"></a>
<a class="sourceLine" id="cb50-91" title="91"> Sort a linked <span class="bu">list</span> <span class="kw">in</span> O(n log n) time using constant space complexity.</a>
<a class="sourceLine" id="cb50-92" title="92"></a>
<a class="sourceLine" id="cb50-93" title="93">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb50-94" title="94"></a>
<a class="sourceLine" id="cb50-95" title="95">    Input: <span class="dv">4</span><span class="op">-&gt;</span><span class="dv">2</span><span class="op">-&gt;</span><span class="dv">1</span><span class="op">-&gt;</span><span class="dv">3</span></a>
<a class="sourceLine" id="cb50-96" title="96">    Output: <span class="dv">1</span><span class="op">-&gt;</span><span class="dv">2</span><span class="op">-&gt;</span><span class="dv">3</span><span class="op">-&gt;</span><span class="dv">4</span></a>
<a class="sourceLine" id="cb50-97" title="97"></a>
<a class="sourceLine" id="cb50-98" title="98"></a>
<a class="sourceLine" id="cb50-99" title="99"></a>
<a class="sourceLine" id="cb50-100" title="100"><span class="op">---</span></a>
<a class="sourceLine" id="cb50-101" title="101"></a>
<a class="sourceLine" id="cb50-102" title="102"><span class="co">### Definition for singly-linked list.</span></a>
<a class="sourceLine" id="cb50-103" title="103"></a>
<a class="sourceLine" id="cb50-104" title="104"><span class="co">### class ListNode(object):</span></a>
<a class="sourceLine" id="cb50-105" title="105"></a>
<a class="sourceLine" id="cb50-106" title="106"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb50-107" title="107"></a>
<a class="sourceLine" id="cb50-108" title="108"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb50-109" title="109"></a>
<a class="sourceLine" id="cb50-110" title="110"><span class="co">### self.next = None</span></a>
<a class="sourceLine" id="cb50-111" title="111"></a>
<a class="sourceLine" id="cb50-112" title="112"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> sortList(<span class="va">self</span>, head):  :<span class="bu">type</span> head: ListNode :rtype: ListNode</a>
<a class="sourceLine" id="cb50-113" title="113"></a>
<a class="sourceLine" id="cb50-114" title="114">        <span class="cf">if</span> <span class="kw">not</span> head <span class="kw">or</span> <span class="kw">not</span> head.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb50-115" title="115">            <span class="cf">return</span> head</a>
<a class="sourceLine" id="cb50-116" title="116"></a>
<a class="sourceLine" id="cb50-117" title="117">        slow, fast <span class="op">=</span> head, head.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-118" title="118"></a>
<a class="sourceLine" id="cb50-119" title="119">        <span class="cf">while</span> fast.<span class="bu">next</span> <span class="kw">and</span> fast.<span class="bu">next</span>.<span class="bu">next</span>:</a>
<a class="sourceLine" id="cb50-120" title="120">            slow <span class="op">=</span> slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-121" title="121">            fast <span class="op">=</span> fast.<span class="bu">next</span>.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-122" title="122"></a>
<a class="sourceLine" id="cb50-123" title="123">        head1, head2 <span class="op">=</span> head, slow.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-124" title="124">        slow.<span class="bu">next</span> <span class="op">=</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb50-125" title="125">        head1 <span class="op">=</span> <span class="va">self</span>.sortList(head1)</a>
<a class="sourceLine" id="cb50-126" title="126">        head2 <span class="op">=</span> <span class="va">self</span>.sortList(head2)</a>
<a class="sourceLine" id="cb50-127" title="127">        head <span class="op">=</span> <span class="va">self</span>.merge(head1, head2)</a>
<a class="sourceLine" id="cb50-128" title="128">        <span class="cf">return</span> head</a>
<a class="sourceLine" id="cb50-129" title="129"></a>
<a class="sourceLine" id="cb50-130" title="130">    <span class="kw">def</span> merge(<span class="va">self</span>, head1, head2):</a>
<a class="sourceLine" id="cb50-131" title="131">        <span class="cf">if</span> <span class="kw">not</span> head1:</a>
<a class="sourceLine" id="cb50-132" title="132">            <span class="cf">return</span> head2</a>
<a class="sourceLine" id="cb50-133" title="133">        <span class="cf">if</span> <span class="kw">not</span> head2:</a>
<a class="sourceLine" id="cb50-134" title="134">            <span class="cf">return</span> head1</a>
<a class="sourceLine" id="cb50-135" title="135"></a>
<a class="sourceLine" id="cb50-136" title="136">        result <span class="op">=</span> ListNode(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb50-137" title="137">        p <span class="op">=</span> result</a>
<a class="sourceLine" id="cb50-138" title="138"></a>
<a class="sourceLine" id="cb50-139" title="139">        <span class="cf">while</span> head1 <span class="kw">and</span> head2:</a>
<a class="sourceLine" id="cb50-140" title="140">            <span class="cf">if</span> head1.val <span class="op">&lt;=</span> head2.val:</a>
<a class="sourceLine" id="cb50-141" title="141">                p.<span class="bu">next</span> <span class="op">=</span> ListNode(head1.val)</a>
<a class="sourceLine" id="cb50-142" title="142">                head1 <span class="op">=</span> head1.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-143" title="143">                p <span class="op">=</span> p.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-144" title="144">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb50-145" title="145">                p.<span class="bu">next</span> <span class="op">=</span> ListNode(head2.val)</a>
<a class="sourceLine" id="cb50-146" title="146">                head2 <span class="op">=</span> head2.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-147" title="147">                p <span class="op">=</span> p.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-148" title="148"></a>
<a class="sourceLine" id="cb50-149" title="149">        <span class="cf">if</span> head1:</a>
<a class="sourceLine" id="cb50-150" title="150">            p.<span class="bu">next</span> <span class="op">=</span> head1</a>
<a class="sourceLine" id="cb50-151" title="151">        <span class="cf">if</span> head2:</a>
<a class="sourceLine" id="cb50-152" title="152">            p.<span class="bu">next</span> <span class="op">=</span> head2</a>
<a class="sourceLine" id="cb50-153" title="153">        <span class="cf">return</span> result.<span class="bu">next</span></a>
<a class="sourceLine" id="cb50-154" title="154"></a>
<a class="sourceLine" id="cb50-155" title="155"> Evaluate the value of an arithmetic expression <span class="kw">in</span> Reverse Polish Notation.</a>
<a class="sourceLine" id="cb50-156" title="156"></a>
<a class="sourceLine" id="cb50-157" title="157">    Valid operators are <span class="op">+</span>, <span class="op">-</span>, <span class="op">*</span>, <span class="op">/</span>. Each operand may be an integer <span class="kw">or</span> another expression.</a>
<a class="sourceLine" id="cb50-158" title="158"></a>
<a class="sourceLine" id="cb50-159" title="159">    Note:</a>
<a class="sourceLine" id="cb50-160" title="160"></a>
<a class="sourceLine" id="cb50-161" title="161">    Division between two integers should truncate toward zero.</a>
<a class="sourceLine" id="cb50-162" title="162">    The given RPN expression <span class="kw">is</span> always valid. That means the expression would always evaluate to a result <span class="kw">and</span> there won<span class="st">&#39;t be any divide by zero operation.</span></a>
<a class="sourceLine" id="cb50-163" title="163"><span class="st">    Example 1:</span></a>
<a class="sourceLine" id="cb50-164" title="164"></a>
<a class="sourceLine" id="cb50-165" title="165"><span class="st">    Input: [&quot;2&quot;, &quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;*&quot;]</span></a>
<a class="sourceLine" id="cb50-166" title="166"><span class="st">    Output: 9</span></a>
<a class="sourceLine" id="cb50-167" title="167"><span class="st">    Explanation: ((2 + 1) * 3) = 9</span></a>
<a class="sourceLine" id="cb50-168" title="168"><span class="st">    Example 2:</span></a>
<a class="sourceLine" id="cb50-169" title="169"></a>
<a class="sourceLine" id="cb50-170" title="170"><span class="st">    Input: [&quot;4&quot;, &quot;13&quot;, &quot;5&quot;, &quot;/&quot;, &quot;+&quot;]</span></a>
<a class="sourceLine" id="cb50-171" title="171"><span class="st">    Output: 6</span></a>
<a class="sourceLine" id="cb50-172" title="172"><span class="st">    Explanation: (4 + (13 / 5)) = 6</span></a>
<a class="sourceLine" id="cb50-173" title="173"></a>
<a class="sourceLine" id="cb50-174" title="174"></a>
<a class="sourceLine" id="cb50-175" title="175"></a>
<a class="sourceLine" id="cb50-176" title="176"><span class="st">class Solution(object): def evalRPN(self, tokens):  :type tokens: List[str] :rtype: int</span></a>
<a class="sourceLine" id="cb50-177" title="177"></a>
<a class="sourceLine" id="cb50-178" title="178"><span class="st">        if not tokens:</span></a>
<a class="sourceLine" id="cb50-179" title="179"><span class="st">            return 0</span></a>
<a class="sourceLine" id="cb50-180" title="180"></a>
<a class="sourceLine" id="cb50-181" title="181"><span class="st">        stack = []</span></a>
<a class="sourceLine" id="cb50-182" title="182"><span class="st">        for val in tokens:</span></a>
<a class="sourceLine" id="cb50-183" title="183"><span class="st">            if val == &quot;+&quot;:</span></a>
<a class="sourceLine" id="cb50-184" title="184"><span class="st">                val1 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-185" title="185"><span class="st">                val2 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-186" title="186"><span class="st">                stack.append(val1 + val2)</span></a>
<a class="sourceLine" id="cb50-187" title="187"><span class="st">            elif val == &quot;-&quot;:</span></a>
<a class="sourceLine" id="cb50-188" title="188"><span class="st">                val1 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-189" title="189"><span class="st">                val2 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-190" title="190"><span class="st">                stack.append(val2 - val1)</span></a>
<a class="sourceLine" id="cb50-191" title="191"><span class="st">            elif val == &quot;*&quot;:</span></a>
<a class="sourceLine" id="cb50-192" title="192"><span class="st">                val1 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-193" title="193"><span class="st">                val2 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-194" title="194"><span class="st">                stack.append(val2 * val1)</span></a>
<a class="sourceLine" id="cb50-195" title="195"><span class="st">            elif val == &quot;/&quot;:</span></a>
<a class="sourceLine" id="cb50-196" title="196"><span class="st">                val1 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-197" title="197"><span class="st">                val2 = stack.pop()</span></a>
<a class="sourceLine" id="cb50-198" title="198"><span class="st">                if val1 * val2 &lt; 0:</span></a>
<a class="sourceLine" id="cb50-199" title="199"><span class="st">                    stack.append(-(-val2 / val1))</span></a>
<a class="sourceLine" id="cb50-200" title="200"><span class="st">                else:</span></a>
<a class="sourceLine" id="cb50-201" title="201"><span class="st">                    stack.append(val2 / val1)</span></a>
<a class="sourceLine" id="cb50-202" title="202"><span class="st">            else:</span></a>
<a class="sourceLine" id="cb50-203" title="203"><span class="st">                stack.append(int(val))</span></a>
<a class="sourceLine" id="cb50-204" title="204"><span class="st">        return stack[0]</span></a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb51">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb51-1" title="1"></a>
<a class="sourceLine" id="cb51-2" title="2"><span class="co">## Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.</span></a>
<a class="sourceLine" id="cb51-3" title="3"></a>
<a class="sourceLine" id="cb51-4" title="4">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb51-5" title="5"></a>
<a class="sourceLine" id="cb51-6" title="6">    Input: [<span class="dv">2</span>,<span class="dv">3</span>,<span class="op">-</span><span class="dv">2</span>,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb51-7" title="7">    Output: <span class="dv">6</span></a>
<a class="sourceLine" id="cb51-8" title="8">    Explanation: [<span class="dv">2</span>,<span class="dv">3</span>] has the largest product <span class="fl">6.</span></a>
<a class="sourceLine" id="cb51-9" title="9"></a>
<a class="sourceLine" id="cb51-10" title="10">    Example <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb51-11" title="11"></a>
<a class="sourceLine" id="cb51-12" title="12">    Input: [<span class="op">-</span><span class="dv">2</span>,<span class="dv">0</span>,<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb51-13" title="13">    Output: <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-14" title="14">    Explanation: The result cannot be <span class="dv">2</span>, because [<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>] <span class="kw">is</span> <span class="kw">not</span> a subarray.</a>
<a class="sourceLine" id="cb51-15" title="15"></a>
<a class="sourceLine" id="cb51-16" title="16"></a>
<a class="sourceLine" id="cb51-17" title="17"></a>
<a class="sourceLine" id="cb51-18" title="18"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> maxProduct(<span class="va">self</span>, nums):  :<span class="bu">type</span> nums: List[<span class="bu">int</span>] :rtype: <span class="bu">int</span></a>
<a class="sourceLine" id="cb51-19" title="19"></a>
<a class="sourceLine" id="cb51-20" title="20">        <span class="cf">if</span> <span class="kw">not</span> nums:</a>
<a class="sourceLine" id="cb51-21" title="21">            <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-22" title="22"></a>
<a class="sourceLine" id="cb51-23" title="23">        max_so_far, min_so_far, result <span class="op">=</span> nums[<span class="dv">0</span>], nums[<span class="dv">0</span>], nums[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb51-24" title="24"></a>
<a class="sourceLine" id="cb51-25" title="25">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</a>
<a class="sourceLine" id="cb51-26" title="26">            <span class="cf">if</span> nums[index] <span class="op">&gt;</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb51-27" title="27">                max_so_far <span class="op">=</span> <span class="bu">max</span>(max_so_far <span class="op">*</span> nums[index], nums[index])</a>
<a class="sourceLine" id="cb51-28" title="28">                min_so_far <span class="op">=</span> <span class="bu">min</span>(min_so_far <span class="op">*</span> nums[index], nums[index])</a>
<a class="sourceLine" id="cb51-29" title="29">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-30" title="30">                temp <span class="op">=</span> max_so_far</a>
<a class="sourceLine" id="cb51-31" title="31">                max_so_far <span class="op">=</span> <span class="bu">max</span>(min_so_far <span class="op">*</span> nums[index], nums[index])</a>
<a class="sourceLine" id="cb51-32" title="32">                min_so_far <span class="op">=</span> <span class="bu">min</span>(temp <span class="op">*</span> nums[index], nums[index])</a>
<a class="sourceLine" id="cb51-33" title="33"></a>
<a class="sourceLine" id="cb51-34" title="34">            result <span class="op">=</span> <span class="bu">max</span>(result, max_so_far)</a>
<a class="sourceLine" id="cb51-35" title="35">        <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb51-36" title="36"></a>
<a class="sourceLine" id="cb51-37" title="37"> Suppose an array <span class="bu">sorted</span> <span class="kw">in</span> ascending order <span class="kw">is</span> rotated at some pivot unknown to you beforehand.</a>
<a class="sourceLine" id="cb51-38" title="38"></a>
<a class="sourceLine" id="cb51-39" title="39">(i.e., [<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>] might become [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>]).</a>
<a class="sourceLine" id="cb51-40" title="40"></a>
<a class="sourceLine" id="cb51-41" title="41">Find the minimum element.</a>
<a class="sourceLine" id="cb51-42" title="42"></a>
<a class="sourceLine" id="cb51-43" title="43">You may assume no duplicate exists <span class="kw">in</span> the array.</a>
<a class="sourceLine" id="cb51-44" title="44"></a>
<a class="sourceLine" id="cb51-45" title="45">Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb51-46" title="46"></a>
<a class="sourceLine" id="cb51-47" title="47">Input: [<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">1</span>,<span class="dv">2</span>] Output: <span class="dv">1</span> Example <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb51-48" title="48"></a>
<a class="sourceLine" id="cb51-49" title="49">Input: [<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>,<span class="dv">0</span>,<span class="dv">1</span>,<span class="dv">2</span>] Output: <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-50" title="50"></a>
<a class="sourceLine" id="cb51-51" title="51"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> findMin(<span class="va">self</span>, nums):  :<span class="bu">type</span> nums: List[<span class="bu">int</span>] :rtype: <span class="bu">int</span>  <span class="cf">if</span> <span class="kw">not</span> nums: <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-52" title="52"></a>
<a class="sourceLine" id="cb51-53" title="53">        <span class="cf">if</span> <span class="bu">len</span>(nums) <span class="op">==</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb51-54" title="54">            <span class="cf">return</span> nums[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb51-55" title="55">        left, right <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-56" title="56"></a>
<a class="sourceLine" id="cb51-57" title="57">        <span class="cf">if</span> nums[left] <span class="op">&lt;</span> nums[right]:</a>
<a class="sourceLine" id="cb51-58" title="58">            <span class="cf">return</span> nums[left]</a>
<a class="sourceLine" id="cb51-59" title="59">        <span class="cf">while</span> left <span class="op">&lt;=</span> right:</a>
<a class="sourceLine" id="cb51-60" title="60">            <span class="cf">while</span> nums[left] <span class="op">==</span> nums[right] <span class="kw">and</span> left <span class="op">!=</span> right:</a>
<a class="sourceLine" id="cb51-61" title="61">                left <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-62" title="62"></a>
<a class="sourceLine" id="cb51-63" title="63">            <span class="cf">if</span> nums[left] <span class="op">&lt;=</span> nums[right]:</a>
<a class="sourceLine" id="cb51-64" title="64">                <span class="cf">return</span> nums[left]</a>
<a class="sourceLine" id="cb51-65" title="65"></a>
<a class="sourceLine" id="cb51-66" title="66">            mid <span class="op">=</span> (left <span class="op">+</span> right) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb51-67" title="67">            <span class="cf">if</span> nums[mid] <span class="op">&gt;=</span> nums[left]:</a>
<a class="sourceLine" id="cb51-68" title="68">                left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-69" title="69">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-70" title="70">                right <span class="op">=</span> mid</a>
<a class="sourceLine" id="cb51-71" title="71">        <span class="cf">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb51-72" title="72"></a>
<a class="sourceLine" id="cb51-73" title="73">’’’ Design a stack that supports push, pop, top, <span class="kw">and</span> retrieving the minimum element <span class="kw">in</span> constant time.</a>
<a class="sourceLine" id="cb51-74" title="74"></a>
<a class="sourceLine" id="cb51-75" title="75">    push(x) <span class="op">--</span> Push element x onto stack.</a>
<a class="sourceLine" id="cb51-76" title="76">    pop() <span class="op">--</span> Removes the element on top of the stack.</a>
<a class="sourceLine" id="cb51-77" title="77">    top() <span class="op">--</span> Get the top element.</a>
<a class="sourceLine" id="cb51-78" title="78">    getMin() <span class="op">--</span> Retrieve the minimum element <span class="kw">in</span> the stack.</a>
<a class="sourceLine" id="cb51-79" title="79">    Example:</a>
<a class="sourceLine" id="cb51-80" title="80">    MinStack minStack <span class="op">=</span> new MinStack()<span class="op">;</span></a>
<a class="sourceLine" id="cb51-81" title="81">    minStack.push(<span class="op">-</span><span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-82" title="82">    minStack.push(<span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-83" title="83">    minStack.push(<span class="op">-</span><span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb51-84" title="84">    minStack.getMin()<span class="op">;</span>   <span class="op">--&gt;</span> Returns <span class="fl">-3.</span></a>
<a class="sourceLine" id="cb51-85" title="85">    minStack.pop()<span class="op">;</span></a>
<a class="sourceLine" id="cb51-86" title="86">    minStack.top()<span class="op">;</span>      <span class="op">--&gt;</span> Returns <span class="fl">0.</span></a>
<a class="sourceLine" id="cb51-87" title="87">    minStack.getMin()<span class="op">;</span>   <span class="op">--&gt;</span> Returns <span class="fl">-2.</span></a>
<a class="sourceLine" id="cb51-88" title="88"></a>
<a class="sourceLine" id="cb51-89" title="89">’’’</a>
<a class="sourceLine" id="cb51-90" title="90"></a>
<a class="sourceLine" id="cb51-91" title="91"><span class="kw">class</span> MinStack(<span class="bu">object</span>):</a>
<a class="sourceLine" id="cb51-92" title="92"></a>
<a class="sourceLine" id="cb51-93" title="93">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb51-94" title="94"></a>
<a class="sourceLine" id="cb51-95" title="95">        initialize your data structure here.</a>
<a class="sourceLine" id="cb51-96" title="96"></a>
<a class="sourceLine" id="cb51-97" title="97">        <span class="va">self</span>.stack <span class="op">=</span> []</a>
<a class="sourceLine" id="cb51-98" title="98">        <span class="va">self</span>.minimum <span class="op">=</span> <span class="bu">float</span>(<span class="st">&#39;inf&#39;</span>)</a>
<a class="sourceLine" id="cb51-99" title="99"></a>
<a class="sourceLine" id="cb51-100" title="100">    <span class="kw">def</span> push(<span class="va">self</span>, x):</a>
<a class="sourceLine" id="cb51-101" title="101"></a>
<a class="sourceLine" id="cb51-102" title="102">        :<span class="bu">type</span> x: <span class="bu">int</span></a>
<a class="sourceLine" id="cb51-103" title="103">        :rtype: void</a>
<a class="sourceLine" id="cb51-104" title="104"></a>
<a class="sourceLine" id="cb51-105" title="105">        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.stack:</a>
<a class="sourceLine" id="cb51-106" title="106">            <span class="va">self</span>.stack.append(x)</a>
<a class="sourceLine" id="cb51-107" title="107">            <span class="va">self</span>.minimum <span class="op">=</span> x</a>
<a class="sourceLine" id="cb51-108" title="108">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-109" title="109">            <span class="cf">if</span> x <span class="op">&lt;</span> <span class="va">self</span>.minimum:</a>
<a class="sourceLine" id="cb51-110" title="110">                <span class="va">self</span>.stack.append(<span class="dv">2</span><span class="op">*</span>x<span class="op">-</span><span class="va">self</span>.minimum)</a>
<a class="sourceLine" id="cb51-111" title="111">                <span class="va">self</span>.minimum <span class="op">=</span> x</a>
<a class="sourceLine" id="cb51-112" title="112">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-113" title="113">                <span class="va">self</span>.stack.append(x)</a>
<a class="sourceLine" id="cb51-114" title="114"></a>
<a class="sourceLine" id="cb51-115" title="115">        <span class="bu">print</span> <span class="va">self</span>.stack</a>
<a class="sourceLine" id="cb51-116" title="116"></a>
<a class="sourceLine" id="cb51-117" title="117">    <span class="kw">def</span> pop(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb51-118" title="118"></a>
<a class="sourceLine" id="cb51-119" title="119">        :rtype: void</a>
<a class="sourceLine" id="cb51-120" title="120"></a>
<a class="sourceLine" id="cb51-121" title="121">        <span class="cf">if</span> <span class="va">self</span>.stack:</a>
<a class="sourceLine" id="cb51-122" title="122">            top <span class="op">=</span> <span class="va">self</span>.stack.pop()</a>
<a class="sourceLine" id="cb51-123" title="123">            <span class="cf">if</span> top <span class="op">&lt;</span> <span class="va">self</span>.minimum:</a>
<a class="sourceLine" id="cb51-124" title="124">                <span class="va">self</span>.minimum <span class="op">=</span> <span class="dv">2</span><span class="op">*</span><span class="va">self</span>.minimum <span class="op">-</span> top</a>
<a class="sourceLine" id="cb51-125" title="125"></a>
<a class="sourceLine" id="cb51-126" title="126">    <span class="kw">def</span> top(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb51-127" title="127"></a>
<a class="sourceLine" id="cb51-128" title="128">        :rtype: <span class="bu">int</span></a>
<a class="sourceLine" id="cb51-129" title="129"></a>
<a class="sourceLine" id="cb51-130" title="130">        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.stack:</a>
<a class="sourceLine" id="cb51-131" title="131">            <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb51-132" title="132">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-133" title="133">            top <span class="op">=</span> <span class="va">self</span>.stack[<span class="op">-</span><span class="dv">1</span>]</a>
<a class="sourceLine" id="cb51-134" title="134">            <span class="cf">if</span> top <span class="op">&lt;</span> <span class="va">self</span>.minimum:</a>
<a class="sourceLine" id="cb51-135" title="135">                <span class="cf">return</span> <span class="va">self</span>.minimum</a>
<a class="sourceLine" id="cb51-136" title="136">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-137" title="137">                <span class="cf">return</span> top</a>
<a class="sourceLine" id="cb51-138" title="138"></a>
<a class="sourceLine" id="cb51-139" title="139">    <span class="kw">def</span> getMin(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb51-140" title="140"></a>
<a class="sourceLine" id="cb51-141" title="141">        :rtype: <span class="bu">int</span></a>
<a class="sourceLine" id="cb51-142" title="142"></a>
<a class="sourceLine" id="cb51-143" title="143">        <span class="cf">if</span> <span class="va">self</span>.stack:</a>
<a class="sourceLine" id="cb51-144" title="144">            <span class="cf">return</span> <span class="va">self</span>.minimum</a>
<a class="sourceLine" id="cb51-145" title="145">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-146" title="146">            <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb51-147" title="147"></a>
<a class="sourceLine" id="cb51-148" title="148"><span class="co">### Your MinStack object will be instantiated and called as such:</span></a>
<a class="sourceLine" id="cb51-149" title="149"></a>
<a class="sourceLine" id="cb51-150" title="150"><span class="co">### obj = MinStack()</span></a>
<a class="sourceLine" id="cb51-151" title="151"></a>
<a class="sourceLine" id="cb51-152" title="152"><span class="co">### obj.push(x)</span></a>
<a class="sourceLine" id="cb51-153" title="153"></a>
<a class="sourceLine" id="cb51-154" title="154"><span class="co">### obj.pop()</span></a>
<a class="sourceLine" id="cb51-155" title="155"></a>
<a class="sourceLine" id="cb51-156" title="156"><span class="co">### param_3 = obj.top()</span></a>
<a class="sourceLine" id="cb51-157" title="157"></a>
<a class="sourceLine" id="cb51-158" title="158"><span class="co">### param_4 = obj.getMin()</span></a>
<a class="sourceLine" id="cb51-159" title="159"></a>
<a class="sourceLine" id="cb51-160" title="160">’’’ Given a string, find the longest substring that contains only two unique characters. For example, given “abcbbbbcccbdddadacb”, the longest substring that contains <span class="dv">2</span> unique character <span class="kw">is</span> “bcbbbbcccb”. ’’’</a>
<a class="sourceLine" id="cb51-161" title="161"></a>
<a class="sourceLine" id="cb51-162" title="162"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> lengthOfLongestSubstringTwoDistinct(<span class="va">self</span>, s):  :<span class="bu">type</span> s: <span class="bu">str</span> :rtype: <span class="bu">int</span>  <span class="cf">if</span> <span class="kw">not</span> s: <span class="cf">return</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-163" title="163"></a>
<a class="sourceLine" id="cb51-164" title="164">        unique_char, start, result <span class="op">=</span> {}, <span class="dv">0</span>, <span class="dv">0</span></a>
<a class="sourceLine" id="cb51-165" title="165">        <span class="cf">for</span> index, char <span class="kw">in</span> <span class="bu">enumerate</span>(s):</a>
<a class="sourceLine" id="cb51-166" title="166">            <span class="cf">if</span> char <span class="kw">in</span> unique_char:</a>
<a class="sourceLine" id="cb51-167" title="167">                unique_char[s] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-168" title="168">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-169" title="169">                unique_char[s] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-170" title="170"></a>
<a class="sourceLine" id="cb51-171" title="171">            <span class="cf">if</span> <span class="bu">len</span>(unique_char) <span class="op">&lt;=</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb51-172" title="172">                result <span class="op">=</span> <span class="bu">max</span>(result, index<span class="op">-</span>start<span class="op">+</span><span class="dv">1</span>)</a>
<a class="sourceLine" id="cb51-173" title="173">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-174" title="174">                <span class="cf">while</span> <span class="bu">len</span>(unique_char) <span class="op">&gt;</span> <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb51-175" title="175">                    char_index <span class="op">=</span> s[start]</a>
<a class="sourceLine" id="cb51-176" title="176">                    count <span class="op">=</span> unique_char[char_index]</a>
<a class="sourceLine" id="cb51-177" title="177">                    <span class="cf">if</span> count <span class="op">==</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb51-178" title="178">                        <span class="kw">del</span> unique_char[char_index]</a>
<a class="sourceLine" id="cb51-179" title="179">                    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-180" title="180">                        unique_char[char_index] <span class="op">-=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-181" title="181">                    start <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-182" title="182">        <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb51-183" title="183"></a>
<a class="sourceLine" id="cb51-184" title="184"> Write a program to find the node at which the intersection of two singly linked lists begins.</a>
<a class="sourceLine" id="cb51-185" title="185"></a>
<a class="sourceLine" id="cb51-186" title="186">    For example, the following two linked lists:</a>
<a class="sourceLine" id="cb51-187" title="187"></a>
<a class="sourceLine" id="cb51-188" title="188">    A:          a1 → a2</a>
<a class="sourceLine" id="cb51-189" title="189">                       ↘</a>
<a class="sourceLine" id="cb51-190" title="190">                         c1 → c2 → c3</a>
<a class="sourceLine" id="cb51-191" title="191">                       ↗</a>
<a class="sourceLine" id="cb51-192" title="192">    B:     b1 → b2 → b3</a>
<a class="sourceLine" id="cb51-193" title="193">    begin to intersect at node c1.</a>
<a class="sourceLine" id="cb51-194" title="194"></a>
<a class="sourceLine" id="cb51-195" title="195"></a>
<a class="sourceLine" id="cb51-196" title="196"></a>
<a class="sourceLine" id="cb51-197" title="197"><span class="op">---</span></a>
<a class="sourceLine" id="cb51-198" title="198"></a>
<a class="sourceLine" id="cb51-199" title="199"><span class="co">### Definition for singly-linked list.</span></a>
<a class="sourceLine" id="cb51-200" title="200"></a>
<a class="sourceLine" id="cb51-201" title="201"><span class="co">### class ListNode(object):</span></a>
<a class="sourceLine" id="cb51-202" title="202"></a>
<a class="sourceLine" id="cb51-203" title="203"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb51-204" title="204"></a>
<a class="sourceLine" id="cb51-205" title="205"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb51-206" title="206"></a>
<a class="sourceLine" id="cb51-207" title="207"><span class="co">### self.next = None</span></a>
<a class="sourceLine" id="cb51-208" title="208"></a>
<a class="sourceLine" id="cb51-209" title="209"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> getIntersectionNode(<span class="va">self</span>, headA, headB):  :<span class="bu">type</span> head1, head1: ListNode :rtype: ListNode  <span class="cf">if</span> <span class="kw">not</span> headA <span class="kw">or</span> <span class="kw">not</span> headB: <span class="cf">return</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb51-210" title="210"></a>
<a class="sourceLine" id="cb51-211" title="211">        pa, pb <span class="op">=</span> headA, headB</a>
<a class="sourceLine" id="cb51-212" title="212">        <span class="cf">while</span> pa <span class="op">!=</span> pb:</a>
<a class="sourceLine" id="cb51-213" title="213">            pa <span class="op">=</span> pa.<span class="bu">next</span> <span class="cf">if</span> pa <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> headB</a>
<a class="sourceLine" id="cb51-214" title="214">            pb <span class="op">=</span> pb.<span class="bu">next</span> <span class="cf">if</span> pb <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span> <span class="cf">else</span> headA</a>
<a class="sourceLine" id="cb51-215" title="215"></a>
<a class="sourceLine" id="cb51-216" title="216">        <span class="cf">return</span> pa <span class="cf">if</span> pa <span class="cf">else</span> <span class="va">None</span></a>
<a class="sourceLine" id="cb51-217" title="217"></a>
<a class="sourceLine" id="cb51-218" title="218"> A peak element <span class="kw">is</span> an element that <span class="kw">is</span> greater than its neighbors.</a>
<a class="sourceLine" id="cb51-219" title="219"></a>
<a class="sourceLine" id="cb51-220" title="220">    Given an <span class="bu">input</span> array nums, where nums[i] ≠ nums[i<span class="op">+</span><span class="dv">1</span>], find a peak element <span class="kw">and</span> <span class="cf">return</span> its index.</a>
<a class="sourceLine" id="cb51-221" title="221"></a>
<a class="sourceLine" id="cb51-222" title="222">    The array may contain multiple peaks, <span class="kw">in</span> that case <span class="cf">return</span> the index to <span class="bu">any</span> one of the peaks <span class="kw">is</span> fine.</a>
<a class="sourceLine" id="cb51-223" title="223"></a>
<a class="sourceLine" id="cb51-224" title="224">    You may imagine that nums[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> nums[n] <span class="op">=</span> <span class="op">-</span>∞.</a>
<a class="sourceLine" id="cb51-225" title="225"></a>
<a class="sourceLine" id="cb51-226" title="226">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb51-227" title="227"></a>
<a class="sourceLine" id="cb51-228" title="228">    Input: nums <span class="op">=</span> [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">1</span>]</a>
<a class="sourceLine" id="cb51-229" title="229">    Output: <span class="dv">2</span></a>
<a class="sourceLine" id="cb51-230" title="230">    Explanation: <span class="dv">3</span> <span class="kw">is</span> a peak element <span class="kw">and</span> your function should <span class="cf">return</span> the index number <span class="fl">2.</span></a>
<a class="sourceLine" id="cb51-231" title="231"></a>
<a class="sourceLine" id="cb51-232" title="232"></a>
<a class="sourceLine" id="cb51-233" title="233"></a>
<a class="sourceLine" id="cb51-234" title="234"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> findPeakElement(<span class="va">self</span>, nums):  :<span class="bu">type</span> nums: List[<span class="bu">int</span>] :rtype: <span class="bu">int</span>  left, right <span class="op">=</span> <span class="dv">0</span>, <span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span> <span class="cf">while</span> left <span class="op">&lt;</span> right: mid <span class="op">=</span> (left <span class="op">+</span> right) <span class="op">/</span> <span class="dv">2</span> <span class="cf">if</span> nums[mid] <span class="op">&gt;</span> nums[mid <span class="op">+</span> <span class="dv">1</span>]: right <span class="op">=</span> mid <span class="cf">else</span>: left <span class="op">=</span> mid <span class="op">+</span> <span class="dv">1</span> <span class="cf">return</span> left</a>
<a class="sourceLine" id="cb51-235" title="235"></a>
<a class="sourceLine" id="cb51-236" title="236"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> findPeakElement(<span class="va">self</span>, nums):  :<span class="bu">type</span> nums: List[<span class="bu">int</span>] :rtype: <span class="bu">int</span>  left <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> <span class="bu">len</span>(nums) right <span class="op">=</span> [<span class="va">False</span>] <span class="op">*</span> <span class="bu">len</span>(nums) left[<span class="dv">0</span>], right[<span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">1</span>] <span class="op">=</span> <span class="va">True</span>, <span class="va">True</span></a>
<a class="sourceLine" id="cb51-237" title="237"></a>
<a class="sourceLine" id="cb51-238" title="238">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(nums)):</a>
<a class="sourceLine" id="cb51-239" title="239">            <span class="cf">if</span> nums[index] <span class="op">&gt;</span> nums[index <span class="op">-</span> <span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb51-240" title="240">                left[index] <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb51-241" title="241"></a>
<a class="sourceLine" id="cb51-242" title="242">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(nums) <span class="op">-</span> <span class="dv">2</span>, <span class="dv">-1</span>, <span class="dv">-1</span>):</a>
<a class="sourceLine" id="cb51-243" title="243">            <span class="cf">if</span> nums[index] <span class="op">&gt;</span> nums[index <span class="op">+</span> <span class="dv">1</span>]:</a>
<a class="sourceLine" id="cb51-244" title="244">                right[index] <span class="op">=</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb51-245" title="245"></a>
<a class="sourceLine" id="cb51-246" title="246">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(left)):</a>
<a class="sourceLine" id="cb51-247" title="247">            <span class="cf">if</span> left[index] <span class="kw">and</span> right[index]:</a>
<a class="sourceLine" id="cb51-248" title="248">                <span class="cf">return</span> index</a>
<a class="sourceLine" id="cb51-249" title="249">        <span class="cf">return</span> <span class="dv">-1</span></a>
<a class="sourceLine" id="cb51-250" title="250"></a>
<a class="sourceLine" id="cb51-251" title="251">’’’ Given a <span class="bu">sorted</span> integer array where the <span class="bu">range</span> of elements are <span class="kw">in</span> the inclusive <span class="bu">range</span> [lower, upper], <span class="cf">return</span> its missing ranges.</a>
<a class="sourceLine" id="cb51-252" title="252"></a>
<a class="sourceLine" id="cb51-253" title="253">For example, given [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">50</span>, <span class="dv">75</span>], lower <span class="op">=</span> <span class="dv">0</span> <span class="kw">and</span> upper <span class="op">=</span> <span class="dv">99</span>, <span class="cf">return</span> [“2”, “<span class="dv">4</span><span class="op">-&gt;</span>49”, “<span class="dv">51</span><span class="op">-&gt;</span>74”, “<span class="dv">76</span><span class="op">-&gt;</span>99”]. ’’’</a>
<a class="sourceLine" id="cb51-254" title="254"></a>
<a class="sourceLine" id="cb51-255" title="255"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> missingRange(<span class="va">self</span>, A, lower, upper): <span class="cf">if</span> <span class="kw">not</span> A: <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb51-256" title="256"></a>
<a class="sourceLine" id="cb51-257" title="257">        result <span class="op">=</span> []</a>
<a class="sourceLine" id="cb51-258" title="258">        <span class="cf">if</span> A[<span class="dv">0</span>] <span class="op">!=</span> lower:</a>
<a class="sourceLine" id="cb51-259" title="259">            end <span class="op">=</span> A[<span class="dv">0</span>] <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-260" title="260">            <span class="cf">if</span> end <span class="op">==</span> lower:</a>
<a class="sourceLine" id="cb51-261" title="261">                m_r <span class="op">=</span> <span class="bu">str</span>(lower)</a>
<a class="sourceLine" id="cb51-262" title="262">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-263" title="263">                m_r <span class="op">=</span> <span class="bu">str</span>(lower) <span class="op">+</span> <span class="st">&quot;-&gt;&quot;</span> <span class="op">+</span> <span class="bu">str</span>(end)</a>
<a class="sourceLine" id="cb51-264" title="264">            result.append(m_r)</a>
<a class="sourceLine" id="cb51-265" title="265"></a>
<a class="sourceLine" id="cb51-266" title="266">        <span class="cf">for</span> index <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="bu">len</span>(A)):</a>
<a class="sourceLine" id="cb51-267" title="267">            <span class="cf">if</span> A[index] <span class="op">!=</span> A[index<span class="dv">-1</span>] <span class="op">+</span> <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb51-268" title="268">                start <span class="op">=</span> A[index<span class="dv">-1</span>] <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-269" title="269">                end <span class="op">=</span> A[index] <span class="op">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-270" title="270">                <span class="cf">if</span> start <span class="op">==</span> end:</a>
<a class="sourceLine" id="cb51-271" title="271">                    m_r <span class="op">=</span> <span class="bu">str</span>(start)</a>
<a class="sourceLine" id="cb51-272" title="272">                <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-273" title="273">                    m_r <span class="op">=</span> <span class="bu">str</span>(start) <span class="op">+</span> <span class="st">&quot;-&gt;&quot;</span> <span class="op">+</span> <span class="bu">str</span>(end)</a>
<a class="sourceLine" id="cb51-274" title="274">                result.append(m_r)</a>
<a class="sourceLine" id="cb51-275" title="275"></a>
<a class="sourceLine" id="cb51-276" title="276">        <span class="cf">if</span> A[<span class="bu">len</span>(A) <span class="op">-</span> <span class="dv">1</span>] <span class="op">!=</span> upper:</a>
<a class="sourceLine" id="cb51-277" title="277">            start <span class="op">=</span> A[<span class="bu">len</span>(A)<span class="op">-</span><span class="dv">1</span>] <span class="op">+</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-278" title="278">            <span class="cf">if</span> start <span class="op">==</span> upper:</a>
<a class="sourceLine" id="cb51-279" title="279">                m_r <span class="op">=</span> <span class="bu">str</span>(start)</a>
<a class="sourceLine" id="cb51-280" title="280">            <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-281" title="281">                m_r <span class="op">=</span> <span class="bu">str</span>(start) <span class="op">+</span> <span class="st">&quot;-&gt;&quot;</span> <span class="op">+</span> <span class="bu">str</span>(upper)</a>
<a class="sourceLine" id="cb51-282" title="282">            result.append(m_r)</a>
<a class="sourceLine" id="cb51-283" title="283">        <span class="cf">return</span> result</a>
<a class="sourceLine" id="cb51-284" title="284"></a>
<a class="sourceLine" id="cb51-285" title="285">solution <span class="op">=</span> Solution() <span class="bu">print</span> solution.missingRange([<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">50</span>, <span class="dv">75</span>], <span class="dv">0</span>, <span class="dv">99</span>) <span class="bu">print</span> solution.missingRange([<span class="dv">4</span>, <span class="dv">10</span>, <span class="dv">50</span>, <span class="dv">98</span>], <span class="dv">0</span>, <span class="dv">99</span>) <span class="bu">print</span> solution.missingRange([<span class="dv">0</span>], <span class="dv">0</span>, <span class="dv">1</span>)  Design <span class="kw">and</span> implement a TwoSum <span class="kw">class</span>. It should support the following operations: add <span class="kw">and</span> find.</a>
<a class="sourceLine" id="cb51-286" title="286"></a>
<a class="sourceLine" id="cb51-287" title="287">add – Add the number to an internal data structure. find – Find <span class="cf">if</span> there exists <span class="bu">any</span> pair of numbers which <span class="bu">sum</span> <span class="kw">is</span> equal to the value.</a>
<a class="sourceLine" id="cb51-288" title="288"></a>
<a class="sourceLine" id="cb51-289" title="289">For example, add(<span class="dv">1</span>)<span class="op">;</span> add(<span class="dv">3</span>)<span class="op">;</span> add(<span class="dv">5</span>)<span class="op">;</span> find(<span class="dv">4</span>) <span class="op">-&gt;</span> true find(<span class="dv">7</span>) <span class="op">-&gt;</span> false</a>
<a class="sourceLine" id="cb51-290" title="290"></a>
<a class="sourceLine" id="cb51-291" title="291"><span class="kw">class</span> TwoSum(<span class="bu">object</span>): <span class="kw">def</span> <span class="op">**</span>init<span class="op">**</span>(<span class="va">self</span>):  initialize your data structure here  <span class="va">self</span>.value_count <span class="op">=</span> {}</a>
<a class="sourceLine" id="cb51-292" title="292"></a>
<a class="sourceLine" id="cb51-293" title="293">    <span class="kw">def</span> add(<span class="va">self</span>, number):</a>
<a class="sourceLine" id="cb51-294" title="294"></a>
<a class="sourceLine" id="cb51-295" title="295">        Add the number to an internal data structure.</a>
<a class="sourceLine" id="cb51-296" title="296">        :rtype: nothing</a>
<a class="sourceLine" id="cb51-297" title="297"></a>
<a class="sourceLine" id="cb51-298" title="298">        <span class="cf">if</span> number <span class="kw">in</span> <span class="va">self</span>.value_count:</a>
<a class="sourceLine" id="cb51-299" title="299">            <span class="va">self</span>.value_count[number] <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-300" title="300">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb51-301" title="301">            <span class="va">self</span>.value_count[number] <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb51-302" title="302"></a>
<a class="sourceLine" id="cb51-303" title="303">    <span class="kw">def</span> find(<span class="va">self</span>, value):</a>
<a class="sourceLine" id="cb51-304" title="304"></a>
<a class="sourceLine" id="cb51-305" title="305">        Find <span class="cf">if</span> there exists <span class="bu">any</span> pair of numbers which <span class="bu">sum</span> <span class="kw">is</span> equal to the value.</a>
<a class="sourceLine" id="cb51-306" title="306">        :<span class="bu">type</span> value: <span class="bu">int</span></a>
<a class="sourceLine" id="cb51-307" title="307">        :rtype: <span class="bu">bool</span></a>
<a class="sourceLine" id="cb51-308" title="308"></a>
<a class="sourceLine" id="cb51-309" title="309">        <span class="cf">for</span> val <span class="kw">in</span> <span class="va">self</span>.value_count:</a>
<a class="sourceLine" id="cb51-310" title="310">            diff <span class="op">=</span> value <span class="op">-</span> val</a>
<a class="sourceLine" id="cb51-311" title="311">            <span class="cf">if</span> diff <span class="kw">in</span> <span class="va">self</span>.value_count <span class="kw">and</span> (diff <span class="op">!=</span> val <span class="kw">or</span> <span class="va">self</span>.value_count[val] <span class="op">&gt;</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb51-312" title="312">                <span class="cf">return</span> <span class="va">True</span></a>
<a class="sourceLine" id="cb51-313" title="313">        <span class="cf">return</span> <span class="va">False</span></a>
<a class="sourceLine" id="cb51-314" title="314"></a>
<a class="sourceLine" id="cb51-315" title="315"><span class="co">### Your TwoSum object will be instantiated and called as such:</span></a>
<a class="sourceLine" id="cb51-316" title="316"></a>
<a class="sourceLine" id="cb51-317" title="317"><span class="co">### twoSum = TwoSum()</span></a>
<a class="sourceLine" id="cb51-318" title="318"></a>
<a class="sourceLine" id="cb51-319" title="319"><span class="co">### twoSum.add(number)</span></a>
<a class="sourceLine" id="cb51-320" title="320"></a>
<a class="sourceLine" id="cb51-321" title="321"><span class="co">### twoSum.find(value)</span></a>
<a class="sourceLine" id="cb51-322" title="322"></a>
<a class="sourceLine" id="cb51-323" title="323"> Implement an iterator over a binary search tree (BST). Your iterator will be initialized <span class="cf">with</span> the root node of a BST.</a>
<a class="sourceLine" id="cb51-324" title="324"></a>
<a class="sourceLine" id="cb51-325" title="325">    Calling <span class="bu">next</span>() will <span class="cf">return</span> the <span class="bu">next</span> smallest number <span class="kw">in</span> the BST.</a>
<a class="sourceLine" id="cb51-326" title="326"></a>
<a class="sourceLine" id="cb51-327" title="327">    Note: <span class="bu">next</span>() <span class="kw">and</span> hasNext() should run <span class="kw">in</span> average O(<span class="dv">1</span>) time <span class="kw">and</span> uses O(h) memory, where h <span class="kw">is</span> the height of the tree.</a>
<a class="sourceLine" id="cb51-328" title="328"></a>
<a class="sourceLine" id="cb51-329" title="329"></a>
<a class="sourceLine" id="cb51-330" title="330"></a>
<a class="sourceLine" id="cb51-331" title="331"><span class="op">---</span></a>
<a class="sourceLine" id="cb51-332" title="332"></a>
<a class="sourceLine" id="cb51-333" title="333"><span class="co">### Definition for a binary tree node</span></a>
<a class="sourceLine" id="cb51-334" title="334"></a>
<a class="sourceLine" id="cb51-335" title="335"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb51-336" title="336"></a>
<a class="sourceLine" id="cb51-337" title="337"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb51-338" title="338"></a>
<a class="sourceLine" id="cb51-339" title="339"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb51-340" title="340"></a>
<a class="sourceLine" id="cb51-341" title="341"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb51-342" title="342"></a>
<a class="sourceLine" id="cb51-343" title="343"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb51-344" title="344"></a>
<a class="sourceLine" id="cb51-345" title="345"><span class="kw">class</span> BSTIterator(<span class="bu">object</span>): <span class="kw">def</span> <span class="op">**</span>init<span class="op">**</span>(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode  <span class="va">self</span>.stack <span class="op">=</span> [] <span class="cf">while</span> root: <span class="va">self</span>.stack.append(root) root <span class="op">=</span> root.left</a>
<a class="sourceLine" id="cb51-346" title="346"></a>
<a class="sourceLine" id="cb51-347" title="347">    <span class="kw">def</span> hasNext(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb51-348" title="348"></a>
<a class="sourceLine" id="cb51-349" title="349">        :rtype: <span class="bu">bool</span></a>
<a class="sourceLine" id="cb51-350" title="350"></a>
<a class="sourceLine" id="cb51-351" title="351">        <span class="cf">return</span> <span class="va">self</span>.stack</a>
<a class="sourceLine" id="cb51-352" title="352"></a>
<a class="sourceLine" id="cb51-353" title="353">    <span class="kw">def</span> <span class="bu">next</span>(<span class="va">self</span>):</a>
<a class="sourceLine" id="cb51-354" title="354"></a>
<a class="sourceLine" id="cb51-355" title="355">        :rtype: <span class="bu">int</span></a>
<a class="sourceLine" id="cb51-356" title="356"></a>
<a class="sourceLine" id="cb51-357" title="357">        node <span class="op">=</span> <span class="va">self</span>.stack.pop()</a>
<a class="sourceLine" id="cb51-358" title="358">        new_node <span class="op">=</span> node.right</a>
<a class="sourceLine" id="cb51-359" title="359">        <span class="cf">while</span> new_node:</a>
<a class="sourceLine" id="cb51-360" title="360">            <span class="va">self</span>.stack.append(new_node)</a>
<a class="sourceLine" id="cb51-361" title="361">            new_node <span class="op">=</span> new_node.left</a>
<a class="sourceLine" id="cb51-362" title="362">        <span class="cf">return</span> node.val</a>
<a class="sourceLine" id="cb51-363" title="363"></a>
<a class="sourceLine" id="cb51-364" title="364"><span class="co">### Your BSTIterator will be called like this:</span></a>
<a class="sourceLine" id="cb51-365" title="365"></a>
<a class="sourceLine" id="cb51-366" title="366"><span class="co">### i, v = BSTIterator(root), []</span></a>
<a class="sourceLine" id="cb51-367" title="367"></a>
<a class="sourceLine" id="cb51-368" title="368"><span class="co">### while i.hasNext(): v.append(i.next())</span></a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb52">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb52-1" title="1"></a>
<a class="sourceLine" id="cb52-2" title="2"><span class="co">## Given a list of non negative integers, arrange them such that they form the largest number.</span></a>
<a class="sourceLine" id="cb52-3" title="3"></a>
<a class="sourceLine" id="cb52-4" title="4">    Example <span class="dv">1</span>:</a>
<a class="sourceLine" id="cb52-5" title="5"></a>
<a class="sourceLine" id="cb52-6" title="6">    Input: [<span class="dv">10</span>,<span class="dv">2</span>]</a>
<a class="sourceLine" id="cb52-7" title="7">    Output: <span class="st">&quot;210&quot;</span></a>
<a class="sourceLine" id="cb52-8" title="8">    Example <span class="dv">2</span>:</a>
<a class="sourceLine" id="cb52-9" title="9"></a>
<a class="sourceLine" id="cb52-10" title="10">    Input: [<span class="dv">3</span>,<span class="dv">30</span>,<span class="dv">34</span>,<span class="dv">5</span>,<span class="dv">9</span>]</a>
<a class="sourceLine" id="cb52-11" title="11">    Output: <span class="st">&quot;9534330&quot;</span></a>
<a class="sourceLine" id="cb52-12" title="12"></a>
<a class="sourceLine" id="cb52-13" title="13"><span class="co">###</span></a>
<a class="sourceLine" id="cb52-14" title="14"></a>
<a class="sourceLine" id="cb52-15" title="15"><span class="kw">class</span> Solution: <span class="co"># &lt;span class=&quot;citation&quot; data-cites=&quot;param&quot;&gt;@param&lt;/span&gt; {integer[]} nums # &lt;span class=&quot;citation&quot; data-cites=&quot;return&quot;&gt;@return&lt;/span&gt; {string} def largestNumber(self, nums): nums = [str(num) for num in nums] nums.sort(cmp=lambda x, y: cmp(y + x, x + y)) return &quot;“.join(nums).lstrip(”0“) or”0&quot;</span></a>
<a class="sourceLine" id="cb52-16" title="16"></a>
<a class="sourceLine" id="cb52-17" title="17"><span class="kw">class</span> Solution: <span class="co"># &lt;span class=&quot;citation&quot; data-cites=&quot;param&quot;&gt;@param&lt;/span&gt; n, an integer # &lt;span class=&quot;citation&quot; data-cites=&quot;return&quot;&gt;@return&lt;/span&gt; an integer def reverseBits(self, n): res = 0 for i in range(32): res += n &amp; 1 n = n &gt;&gt; 1 if i != 31: res = res &lt;&lt; 1 return res</span></a>
<a class="sourceLine" id="cb52-18" title="18"></a>
<a class="sourceLine" id="cb52-19" title="19"><span class="bu">print</span> Solution().reverseBits(<span class="dv">12</span>) <span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> hammingWeight(<span class="va">self</span>, n):  :<span class="bu">type</span> n: <span class="bu">int</span> :rtype: <span class="bu">int</span>  bits <span class="op">=</span> <span class="dv">0</span> mask <span class="op">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb52-20" title="20"></a>
<a class="sourceLine" id="cb52-21" title="21">        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">32</span>):</a>
<a class="sourceLine" id="cb52-22" title="22">            <span class="cf">if</span> (n <span class="op">&amp;</span> mask) <span class="op">!=</span> <span class="dv">0</span>:</a>
<a class="sourceLine" id="cb52-23" title="23">                bits <span class="op">+=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb52-24" title="24">            mask <span class="op">&lt;&lt;=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb52-25" title="25"></a>
<a class="sourceLine" id="cb52-26" title="26">        <span class="cf">return</span> bits</a></code></pre>
    </div>
    <hr />
    <div class="sourceCode" id="cb53">
      <pre
        class="sourceCode py"
      ><code class="sourceCode python"><a class="sourceLine" id="cb53-1" title="1"></a>
<a class="sourceLine" id="cb53-2" title="2"><span class="co">## Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</span></a>
<a class="sourceLine" id="cb53-3" title="3"></a>
<a class="sourceLine" id="cb53-4" title="4">    Example:</a>
<a class="sourceLine" id="cb53-5" title="5"></a>
<a class="sourceLine" id="cb53-6" title="6">    Input: [<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,null,<span class="dv">5</span>,null,<span class="dv">4</span>]</a>
<a class="sourceLine" id="cb53-7" title="7">    Output: [<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>]</a>
<a class="sourceLine" id="cb53-8" title="8">    Explanation:</a>
<a class="sourceLine" id="cb53-9" title="9"></a>
<a class="sourceLine" id="cb53-10" title="10">       <span class="dv">1</span>            <span class="op">&lt;---</span></a>
<a class="sourceLine" id="cb53-11" title="11">     <span class="op">/</span>   <span class="op">\</span></a>
<a class="sourceLine" id="cb53-12" title="12">    <span class="dv">2</span>     <span class="dv">3</span>         <span class="op">&lt;---</span></a>
<a class="sourceLine" id="cb53-13" title="13">     <span class="op">\</span>     <span class="op">\</span></a>
<a class="sourceLine" id="cb53-14" title="14">      <span class="dv">5</span>     <span class="dv">4</span>       <span class="op">&lt;---</span></a>
<a class="sourceLine" id="cb53-15" title="15"></a>
<a class="sourceLine" id="cb53-16" title="16"></a>
<a class="sourceLine" id="cb53-17" title="17"></a>
<a class="sourceLine" id="cb53-18" title="18"><span class="op">---</span></a>
<a class="sourceLine" id="cb53-19" title="19"></a>
<a class="sourceLine" id="cb53-20" title="20"><span class="co">### Definition for a binary tree node.</span></a>
<a class="sourceLine" id="cb53-21" title="21"></a>
<a class="sourceLine" id="cb53-22" title="22"><span class="co">### class TreeNode(object):</span></a>
<a class="sourceLine" id="cb53-23" title="23"></a>
<a class="sourceLine" id="cb53-24" title="24"><span class="co">### def **init**(self, x):</span></a>
<a class="sourceLine" id="cb53-25" title="25"></a>
<a class="sourceLine" id="cb53-26" title="26"><span class="co">### self.val = x</span></a>
<a class="sourceLine" id="cb53-27" title="27"></a>
<a class="sourceLine" id="cb53-28" title="28"><span class="co">### self.left = None</span></a>
<a class="sourceLine" id="cb53-29" title="29"></a>
<a class="sourceLine" id="cb53-30" title="30"><span class="co">### self.right = None</span></a>
<a class="sourceLine" id="cb53-31" title="31"></a>
<a class="sourceLine" id="cb53-32" title="32"><span class="kw">class</span> Solution(<span class="bu">object</span>): <span class="kw">def</span> rightSideView(<span class="va">self</span>, root):  :<span class="bu">type</span> root: TreeNode :rtype: List[<span class="bu">int</span>]  <span class="cf">if</span> <span class="kw">not</span> root: <span class="cf">return</span> []</a>
<a class="sourceLine" id="cb53-33" title="33"></a>
<a class="sourceLine" id="cb53-34" title="34">        stack, node_depth <span class="op">=</span> [(root, <span class="dv">0</span>)], {}</a>
<a class="sourceLine" id="cb53-35" title="35"></a>
<a class="sourceLine" id="cb53-36" title="36">        <span class="cf">while</span> stack:</a>
<a class="sourceLine" id="cb53-37" title="37">            node, depth <span class="op">=</span> stack.pop(<span class="dv">0</span>)</a>
<a class="sourceLine" id="cb53-38" title="38">            <span class="cf">if</span> depth <span class="kw">not</span> <span class="kw">in</span> node_depth:</a>
<a class="sourceLine" id="cb53-39" title="39">                node_depth[depth] <span class="op">=</span> node.val</a>
<a class="sourceLine" id="cb53-40" title="40"></a>
<a class="sourceLine" id="cb53-41" title="41">            <span class="cf">if</span> node.right:</a>
<a class="sourceLine" id="cb53-42" title="42">                stack.append((node.right, depth <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb53-43" title="43">            <span class="cf">if</span> node.left:</a>
<a class="sourceLine" id="cb53-44" title="44">                stack.append((node.left, depth <span class="op">+</span> <span class="dv">1</span>))</a>
<a class="sourceLine" id="cb53-45" title="45">        <span class="cf">return</span> node_depth.values()</a></code></pre>
    </div>
  </body>
</html>
