<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Doubly Linked List</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="doubly-linked-list">Doubly Linked List</h1>
<p>Singly Linked List is a linear and connected data structure made of Nodes. Each node is composed of a variable <code>data</code> where its content is stored and a pointer to the next Node on the list. The Linked List has a pointer to the first element of this Node sequence and may also have another pointer to the last Node to make operations at the far end less time-consuming. You can also store a <code>length</code> variable to store the total length.</p>
<p>A <strong>Doubly Linked List (DLL)</strong> contains an extra pointer, typically called previous pointer, together with next pointer and data which are there in singly linked list.</p>
<h3 id="advantages-over-singly-linked-list">Advantages over singly linked list</h3>
<ul>
<li>A DLL can be traversed in both forward and backward direction.</li>
<li>The delete operation in DLL is more efficient if pointer to the node to be deleted is given.</li>
<li>We can quickly insert a new node before a given node. In singly linked list, to delete a node, pointer to the previous node is needed. To get this previous node, sometimes the list is traversed. In DLL, we can get the previous node using previous pointer.</li>
</ul>
<h3 id="disadvantages-over-singly-linked-list">Disadvantages over singly linked list</h3>
<ul>
<li>Every node of DLL Require extra space for an previous pointer. It is possible to implement DLL with single pointer though (See this and this).</li>
<li>All operations require an extra pointer previous to be maintained. For example, in insertion, we need to modify previous pointers together with next pointers. For example in following functions for insertions at different positions, we need 1 or 2 extra steps to set previous pointer.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<table>
<thead>
<tr class="header">
<th>Operation</th>
<th>Average</th>
<th>Worst</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Access</td>
<td>Θ(n)</td>
<td>O(n)</td>
</tr>
<tr class="even">
<td>Search</td>
<td>Θ(n)</td>
<td>O(n)</td>
</tr>
<tr class="odd">
<td>Insertion</td>
<td>Θ(1)</td>
<td>O(1)</td>
</tr>
<tr class="even">
<td>Deletion</td>
<td>Θ(1)</td>
<td>O(1)</td>
</tr>
</tbody>
</table>
<h2 id="example">Example</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">class</span> <span class="bu">LinkedList</span> {</a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="bu">Node</span> head;      <span class="co">// Pointer to the first element</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="bu">Node</span> tail;      <span class="co">// Optional. Points to the last element</span></a>
<a class="sourceLine" id="cb1-5" title="5"></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="dt">int</span> length;     <span class="co">// Optional</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8">    <span class="kw">class</span> <span class="bu">Node</span> {</a>
<a class="sourceLine" id="cb1-9" title="9">        <span class="dt">int</span> data;   <span class="co">// Node data. Can be int, string, float, templates, etc</span></a>
<a class="sourceLine" id="cb1-10" title="10">        <span class="bu">Node</span> next;  <span class="co">// Pointer to the next node on the list</span></a>
<a class="sourceLine" id="cb1-11" title="11">        <span class="bu">Node</span> prev;</a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13">        <span class="bu">Node</span>(<span class="dt">int</span> data) {</a>
<a class="sourceLine" id="cb1-14" title="14">            <span class="kw">this</span>.<span class="fu">data</span> = data;</a>
<a class="sourceLine" id="cb1-15" title="15">        }</a>
<a class="sourceLine" id="cb1-16" title="16">    }</a>
<a class="sourceLine" id="cb1-17" title="17"></a>
<a class="sourceLine" id="cb1-18" title="18"></a>
<a class="sourceLine" id="cb1-19" title="19">    <span class="co">// Adding a node at the front of the list</span></a>
<a class="sourceLine" id="cb1-20" title="20">    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">push</span>(<span class="dt">int</span> new_data) {</a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22">        <span class="co">/* 1. allocate node</span></a>
<a class="sourceLine" id="cb1-23" title="23"><span class="co">         * 2. put in the data */</span></a>
<a class="sourceLine" id="cb1-24" title="24">        <span class="bu">Node</span> new_Node = <span class="kw">new</span> <span class="bu">Node</span>(new_data);</a>
<a class="sourceLine" id="cb1-25" title="25"></a>
<a class="sourceLine" id="cb1-26" title="26">        <span class="co">/* 3. Make next of new node as head and previous as NULL */</span></a>
<a class="sourceLine" id="cb1-27" title="27">        new_Node.<span class="fu">next</span> = head;</a>
<a class="sourceLine" id="cb1-28" title="28">        new_Node.<span class="fu">prev</span> = <span class="kw">null</span>;</a>
<a class="sourceLine" id="cb1-29" title="29"></a>
<a class="sourceLine" id="cb1-30" title="30">        <span class="co">/* 4. change prev of head node to new node */</span></a>
<a class="sourceLine" id="cb1-31" title="31">        <span class="kw">if</span> (head != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb1-32" title="32">            head.<span class="fu">prev</span> = new_Node;</a>
<a class="sourceLine" id="cb1-33" title="33"></a>
<a class="sourceLine" id="cb1-34" title="34">        <span class="co">/* 5. move the head to point to the new node */</span></a>
<a class="sourceLine" id="cb1-35" title="35">        head = new_Node;</a>
<a class="sourceLine" id="cb1-36" title="36">    }</a>
<a class="sourceLine" id="cb1-37" title="37"></a>
<a class="sourceLine" id="cb1-38" title="38">    <span class="co">/* Given a node as prev_node, insert a new node after the given node */</span></a>
<a class="sourceLine" id="cb1-39" title="39">    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">InsertAfter</span>(<span class="bu">Node</span> prev_Node, <span class="dt">int</span> new_data) {</a>
<a class="sourceLine" id="cb1-40" title="40"></a>
<a class="sourceLine" id="cb1-41" title="41">        <span class="co">/*1. check if the given prev_node is NULL */</span></a>
<a class="sourceLine" id="cb1-42" title="42">        <span class="kw">if</span> (prev_Node == <span class="kw">null</span>) {</a>
<a class="sourceLine" id="cb1-43" title="43">            <span class="bu">System</span>.<span class="fu">out</span>.<span class="fu">println</span>(<span class="st">&quot;The given previous node cannot be NULL &quot;</span>);</a>
<a class="sourceLine" id="cb1-44" title="44">            <span class="kw">return</span>;</a>
<a class="sourceLine" id="cb1-45" title="45">        }</a>
<a class="sourceLine" id="cb1-46" title="46"></a>
<a class="sourceLine" id="cb1-47" title="47">        <span class="co">/* 2. allocate node</span></a>
<a class="sourceLine" id="cb1-48" title="48"><span class="co">         * 3. put in the data */</span></a>
<a class="sourceLine" id="cb1-49" title="49">        <span class="bu">Node</span> new_node = <span class="kw">new</span> <span class="bu">Node</span>(new_data);</a>
<a class="sourceLine" id="cb1-50" title="50"></a>
<a class="sourceLine" id="cb1-51" title="51">        <span class="co">/* 4. Make next of new node as next of prev_node */</span></a>
<a class="sourceLine" id="cb1-52" title="52">        new_node.<span class="fu">next</span> = prev_Node.<span class="fu">next</span>;</a>
<a class="sourceLine" id="cb1-53" title="53"></a>
<a class="sourceLine" id="cb1-54" title="54">        <span class="co">/* 5. Make the next of prev_node as new_node */</span></a>
<a class="sourceLine" id="cb1-55" title="55">        prev_Node.<span class="fu">next</span> = new_node;</a>
<a class="sourceLine" id="cb1-56" title="56"></a>
<a class="sourceLine" id="cb1-57" title="57">        <span class="co">/* 6. Make prev_node as previous of new_node */</span></a>
<a class="sourceLine" id="cb1-58" title="58">        new_node.<span class="fu">prev</span> = prev_Node;</a>
<a class="sourceLine" id="cb1-59" title="59"></a>
<a class="sourceLine" id="cb1-60" title="60">        <span class="co">/* 7. Change previous of new_node&#39;s next node */</span></a>
<a class="sourceLine" id="cb1-61" title="61">        <span class="kw">if</span> (new_node.<span class="fu">next</span> != <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb1-62" title="62">            new_node.<span class="fu">next</span>.<span class="fu">prev</span> = new_node;</a>
<a class="sourceLine" id="cb1-63" title="63">    }</a>
<a class="sourceLine" id="cb1-64" title="64">}</a></code></pre></div>
<h3 id="adding-node-at-front">Adding node at front</h3>
<figure>
<img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/03/DLL_add_front1.png" alt="Tracing of algorithm" /><figcaption>Tracing of algorithm</figcaption>
</figure>
<h3 id="add-a-node-after-a-given-node">Add a node after a given node</h3>
<figure>
<img src="https://www.geeksforgeeks.org/wp-content/uploads/gq/2014/03/DLL_add_middle1.png" alt="Tracing of algorithm" /><figcaption>Tracing of algorithm</figcaption>
</figure>
<h2 id="code-implementation-links">Code Implementation Links</h2>
<ul>
<li><a href="https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Lists/DoublyLinkedList.java">Java</a></li>
<li><a href="https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Data%20Structure/Doubly%20Linked%20List.cpp">C++</a></li>
<li><a href="https://github.com/TheAlgorithms/Python/blob/master/data_structures/linked_list/doubly_linked_list.py">Python</a></li>
<li><a href="https://github.com/TheAlgorithms/Go/blob/master/data-structures/linked-list/double-linkedlist.go">Go</a></li>
<li><a href="https://github.com/TheAlgorithms/Ruby/blob/master/data_structures/linked_lists/double_list.rb">Ruby</a></li>
</ul>
<h2 id="video-explanation">Video Explanation</h2>
<p><a href="https://www.youtube.com/watch?v=FHMPswJDCvU">A CS50 video explaining the Doubly Linked List Data Structure</a></p>
</body>
</html>
