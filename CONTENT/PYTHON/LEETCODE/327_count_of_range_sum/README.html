<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
</head>
<body>
<p>We can to record the sums, put sum from start up to index i into sums[i+1]. Then a O(N^2) solution is to loop over each pair of indices (i, j), if lower&lt;=sums[j]-sums[i]&lt;=upper, then we find a range with sum that satisfies the condition.</p>
<p>To do better, we have to divide and conquer. Observe that if we divide a range (I,J) into (I, mid) and (mid, J), then the pair of indices that satisfies the constraint have to be:</p>
<ol type="1">
<li>both between I and mid</li>
<li>both between mid and J</li>
<li>i is between I and mid, j is between mid and J</li>
</ol>
<p>if we already solved the sub-problems of 1) and 2), we only need to count the pairs for 3).</p>
<p>If i is in (I, mid) and j is in (mid, J), then the order of 2 subsequences doesnâ€™t matter. We can sort both subsequences, and for each item i in range 1), use 2 cursors in range 2) to find the number of items j, with sums[j]-sum[i] between (lower, upper). Since the subsequence is ordered, the cursors can be reused in the inner loop for the next i.</p>
<p>The time complexity for this solution is O(N*log(N)).</p>
</body>
</html>
